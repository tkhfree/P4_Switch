generated_code = ""

# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from src/utils/codegen.sugar.py), do not modify directly.
# Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

global file_indentation_level
file_indentation_level = 0

# The last element is the innermost (current) style.
file_sugar_style = ['line_comment']


def add_code(line, lineno = None, file = "src/utils/codegen.sugar.py"):
    global file_indentation_level
    global file_sugar_style
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
    }

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = '    ' * file_indentation_level
    return indent + line + sugar(no_sugar_on_line, file, lineno) + line_ends[file_sugar_style[-1]]


class SugarStyle():
    def __init__(self, sugar):
        global file_sugar_style
        file_sugar_style.append(sugar)

    def __enter__(self):
        global file_sugar_style
        return file_sugar_style[-1]

    def __exit__(self, type, value, traceback):
        global file_sugar_style
        file_sugar_style.pop()


def sugar(no_sugar_on_line, file, lineno):
    if no_sugar_on_line or file is None or lineno is None:
        return ""

    import re
    global file_sugar_style

    if file_sugar_style[-1] == 'line_comment':
        if no_sugar_on_line:
            return ""
        return " // {}:{}".format(file, lineno)
    if file_sugar_style[-1] == 'inline_comment':
        if file == "utils/codegen.sugar.py":
            return " /* {} */ {}".format(lineno)
        return " /* {}:{} */".format(file, lineno)
    return line


generated_code += "// Autogenerated file (from src/utils/codegen.sugar.py via utils/codegen.sugar.py), do not modify directly.\n"
generated_code += "// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)\n"
generated_code += "\n"

# Copyright 2017 Eotvos Lorand University, Budapest, Hungary ## src/utils/codegen.sugar.py:1
#  ## src/utils/codegen.sugar.py:2
# Licensed under the Apache License, Version 2.0 (the "License"); ## src/utils/codegen.sugar.py:3
# you may not use this file except in compliance with the License. ## src/utils/codegen.sugar.py:4
# You may obtain a copy of the License at ## src/utils/codegen.sugar.py:5
#  ## src/utils/codegen.sugar.py:6
#     http://www.apache.org/licenses/LICENSE-2.0 ## src/utils/codegen.sugar.py:7
#  ## src/utils/codegen.sugar.py:8
# Unless required by applicable law or agreed to in writing, software ## src/utils/codegen.sugar.py:9
# distributed under the License is distributed on an "AS IS" BASIS, ## src/utils/codegen.sugar.py:10
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ## src/utils/codegen.sugar.py:11
# See the License for the specific language governing permissions and ## src/utils/codegen.sugar.py:12
# limitations under the License. ## src/utils/codegen.sugar.py:13
from utils.misc import addWarning, addError ## src/utils/codegen.sugar.py:14

################################################################################ ## src/utils/codegen.sugar.py:16

SHORT_STDPARAMS = "packet_descriptor_t* pd, lookup_table_t** tables" ## src/utils/codegen.sugar.py:18
SHORT_STDPARAMS_IN = "pd, tables" ## src/utils/codegen.sugar.py:19
STDPARAMS = SHORT_STDPARAMS + ", parser_state_t* pstate" ## src/utils/codegen.sugar.py:20
STDPARAMS_IN = SHORT_STDPARAMS_IN + ", pstate" ## src/utils/codegen.sugar.py:21

################################################################################ ## src/utils/codegen.sugar.py:23

type_env = {} ## src/utils/codegen.sugar.py:25

def gen_format_type(t, resolve_names = True, use_array = False, addon = ""): ## src/utils/codegen.sugar.py:27
    generated_code = ""
    """Returns a type. If the type has a part that has to come after the variable name in a declaration, ## src/utils/codegen.sugar.py:28
    such as [20] in uint8_t varname[20], it should be separated with a space.""" ## src/utils/codegen.sugar.py:29
    if t.node_type == 'Type_Specialized': ## src/utils/codegen.sugar.py:30
        extern_name = t.baseType.path.name ## src/utils/codegen.sugar.py:31

        # TODO is there a more straightforward way to deal with such externs? ## src/utils/codegen.sugar.py:33
        argtyped_externs = ["Digest"] ## src/utils/codegen.sugar.py:34

        if extern_name in argtyped_externs: ## src/utils/codegen.sugar.py:36
            generated_code += add_code(' {}'.format(t.arguments[0].type_ref.name), 36)
        else: ## src/utils/codegen.sugar.py:38
            param_count = len(t.baseType.type_ref.typeParameters.parameters) ## src/utils/codegen.sugar.py:39
            if param_count != 1: ## src/utils/codegen.sugar.py:40
                addError('formatting type', 'Type {} has {} parameters; only 1 parameter is supported'.format(t.name, param_count)) ## src/utils/codegen.sugar.py:41

            type_name = gen_format_type(t.arguments[0]._type_ref, resolve_names) ## src/utils/codegen.sugar.py:43
            generated_code += add_code(' {}_{}'.format(extern_name, type_name), 43)
    elif t.node_type == 'Type_Void': ## src/utils/codegen.sugar.py:45
        generated_code += add_code(" void", 45)
    elif t.node_type == 'Type_Boolean': ## src/utils/codegen.sugar.py:47
        generated_code += add_code(" bool", 47)
    elif t.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:49
        res = 'int' if t.isSigned else 'uint' ## src/utils/codegen.sugar.py:50
        if t.size <= 8: ## src/utils/codegen.sugar.py:51
            res += '8_t' ## src/utils/codegen.sugar.py:52
        elif t.size <= 16: ## src/utils/codegen.sugar.py:53
            res += '16_t' ## src/utils/codegen.sugar.py:54
        elif t.size <= 32: ## src/utils/codegen.sugar.py:55
            res += '32_t' ## src/utils/codegen.sugar.py:56
        elif use_array: ## src/utils/codegen.sugar.py:57
            res += '8_t [{}]'.format((t.size+7)/8) ## src/utils/codegen.sugar.py:58
        else: ## src/utils/codegen.sugar.py:59
            res += '8_t*' ## src/utils/codegen.sugar.py:60
        return res ## src/utils/codegen.sugar.py:61
    elif t.node_type == 'Type_Name': ## src/utils/codegen.sugar.py:62
        if t.type_ref.node_type in {'Type_Enum', 'Type_Error'}: ## src/utils/codegen.sugar.py:63
            generated_code += add_code(' enum {}'.format(t.type_ref.c_name), 63)
        else: ## src/utils/codegen.sugar.py:65
            if not resolve_names: ## src/utils/codegen.sugar.py:66
                return t.type_ref.name ## src/utils/codegen.sugar.py:67

            global type_env ## src/utils/codegen.sugar.py:69

            if t.type_ref.name in type_env: ## src/utils/codegen.sugar.py:71
                return type_env[t.type_ref.name] ## src/utils/codegen.sugar.py:72

            generated_code += add_code(' {}'.format(t.type_ref.name), 73)
    elif t.node_type == 'Type_Extern': ## src/utils/codegen.sugar.py:75
        generated_code += add_code(' {}_t'.format(t.name), 75)
    elif t.node_type == 'Type_Struct': ## src/utils/codegen.sugar.py:77
        struct_name = "{}_s".format(t.name[:-2]) if t.name.endswith("_t") else t.name ## src/utils/codegen.sugar.py:78
        generated_code += add_code(' struct {}'.format(struct_name), 78)
    elif t.node_type == 'Type_Varbits': ## src/utils/codegen.sugar.py:80
        generated_code += add_code(' uint8_t [{}] /* preliminary type for varbits */'.format((t.size+7)/8), 80)
    else: ## src/utils/codegen.sugar.py:82
        addError('formatting type', 'Type {} for node ({}) is not supported yet!'.format(t.node_type, t)) ## src/utils/codegen.sugar.py:83
        generated_code += add_code(' int /* generated in place of unknown type {} */'.format(t.node_type), 83)

    return generated_code

def pp_type_16(t): ## src/utils/codegen.sugar.py:86
    """Pretty print P4_16 type""" ## src/utils/codegen.sugar.py:87
    if t.node_type == 'Type_Boolean': ## src/utils/codegen.sugar.py:88
        return 'bool' ## src/utils/codegen.sugar.py:89
    elif t.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:90
        return ('int' if t.isSigned else 'bit') + '<' + str(t.size) + '>' ## src/utils/codegen.sugar.py:91
    else: ## src/utils/codegen.sugar.py:92
        return str(t) ## src/utils/codegen.sugar.py:93

def gen_format_type_mask(t): ## src/utils/codegen.sugar.py:95
    generated_code = ""
    if t.node_type == 'Type_Bits' and not t.isSigned: ## src/utils/codegen.sugar.py:96
        mask = hex((2 ** t.size) - 1) ## src/utils/codegen.sugar.py:97
        generated_code += add_code(' {}&'.format(mask), 97)
    else: ## src/utils/codegen.sugar.py:99
        addError('formatting a type mask', 'Currently only bit<w> is supported!') ## src/utils/codegen.sugar.py:100

    return generated_code

def method_parameters_by_type(args, method_params): ## src/utils/codegen.sugar.py:102
    for (par, tpar) in zip(args, method_params.parameters): ## src/utils/codegen.sugar.py:103
        if tpar('type.type_ref.is_metadata', False): ## src/utils/codegen.sugar.py:104
            continue ## src/utils/codegen.sugar.py:105

        yield (par, tpar.type) ## src/utils/codegen.sugar.py:107

def format_method_parameter(par): ## src/utils/codegen.sugar.py:109
    if hasattr(par, 'field_ref'): ## src/utils/codegen.sugar.py:110
        return 'handle(header_desc_ins(pd, {}), {})'.format(par.expr.header_ref.id, par.expression.field_ref.id) ## src/utils/codegen.sugar.py:111
    else: ## src/utils/codegen.sugar.py:112
        return format_expr(par) ## src/utils/codegen.sugar.py:113

def gen_format_method_parameters(args, method_params): ## src/utils/codegen.sugar.py:115
    generated_code = ""
    return ', '.join([format_method_parameter(par) for (par, tpar) in method_parameters_by_type(args, method_params)]) ## src/utils/codegen.sugar.py:116

    return generated_code

def gen_format_declaration(d, varname_override): ## src/utils/codegen.sugar.py:118
    generated_code = ""
    var_name = d.name if varname_override is None else varname_override ## src/utils/codegen.sugar.py:119

    if d.node_type == 'Declaration_Variable': ## src/utils/codegen.sugar.py:121
        if d.type('type_ref.node_type', 'not header') == 'Type_Header': ## src/utils/codegen.sugar.py:122
            # Data for variable width headers is stored in parser_state_t ## src/utils/codegen.sugar.py:123
            pass ## src/utils/codegen.sugar.py:124
        elif d.type.node_type == 'Type_Boolean': ## src/utils/codegen.sugar.py:125
            generated_code += add_code(' bool {} = false;'.format(var_name), 125)
        else: ## src/utils/codegen.sugar.py:127
            t = gen_format_type(d.type, False) ## src/utils/codegen.sugar.py:128
            generated_code += add_code(' {} {};'.format(t, var_name), 128)
    elif d.node_type == 'Declaration_Instance': ## src/utils/codegen.sugar.py:130
        t = gen_format_type(d.type, False) + "_t" ## src/utils/codegen.sugar.py:131
        generated_code += add_code(' extern void {}_init({}*);'.format(t, t), 131)
        generated_code += add_code(' {} {};'.format(t, var_name), 132)
        generated_code += add_code(' {}_init(&{});'.format(t, var_name), 133)
    elif d.node_type in ['P4Table', 'P4Action']: ## src/utils/codegen.sugar.py:135
        generated_code += add_code(" /* nothing */", 135)
    else: ## src/utils/codegen.sugar.py:137
        addError('formatting declaration', 'Declaration of type %s is not supported yet!' % d.node_type) ## src/utils/codegen.sugar.py:138

    return generated_code

################################################################################ ## src/utils/codegen.sugar.py:140

def is_metadata(e): ## src/utils/codegen.sugar.py:142
    if e.node_type == 'Member': ## src/utils/codegen.sugar.py:143
        if hasattr(e.expr, 'header_ref'): ## src/utils/codegen.sugar.py:144
            return e.expr.header_ref.type.type_ref.is_metadata ## src/utils/codegen.sugar.py:145
        elif hasattr(e.expr.type, 'is_metadata'): ## src/utils/codegen.sugar.py:146
            return e.expr.type.is_metadata ## src/utils/codegen.sugar.py:147
        else: ## src/utils/codegen.sugar.py:148
            return False ## src/utils/codegen.sugar.py:149
    return False ## src/utils/codegen.sugar.py:150


def is_std_metadata(e): ## src/utils/codegen.sugar.py:153
    return is_metadata(e) and e.expr.type.name == 'standard_metadata_t' ## src/utils/codegen.sugar.py:154

################################################################################ ## src/utils/codegen.sugar.py:156

enclosing_control = None ## src/utils/codegen.sugar.py:158

pre_statement_buffer = "" ## src/utils/codegen.sugar.py:160
post_statement_buffer = "" ## src/utils/codegen.sugar.py:161

def prepend_statement(s): ## src/utils/codegen.sugar.py:163
    global pre_statement_buffer ## src/utils/codegen.sugar.py:164
    pre_statement_buffer += "\n" + s ## src/utils/codegen.sugar.py:165

def append_statement(s): ## src/utils/codegen.sugar.py:167
    global post_statement_buffer ## src/utils/codegen.sugar.py:168
    post_statement_buffer += s + "\n" ## src/utils/codegen.sugar.py:169

def statement_buffer_value(): ## src/utils/codegen.sugar.py:171
    global pre_statement_buffer ## src/utils/codegen.sugar.py:172
    global post_statement_buffer ## src/utils/codegen.sugar.py:173
    ret = (pre_statement_buffer, post_statement_buffer) ## src/utils/codegen.sugar.py:174
    pre_statement_buffer = "" ## src/utils/codegen.sugar.py:175
    post_statement_buffer = "" ## src/utils/codegen.sugar.py:176
    return ret ## src/utils/codegen.sugar.py:177


def is_control_local_var(var_name): ## src/utils/codegen.sugar.py:180
    global enclosing_control ## src/utils/codegen.sugar.py:181

    def get_locals(node): ## src/utils/codegen.sugar.py:183
        if node.node_type == 'P4Parser':  return node.parserLocals ## src/utils/codegen.sugar.py:184
        if node.node_type == 'P4Control': return node.controlLocals ## src/utils/codegen.sugar.py:185
        return [] ## src/utils/codegen.sugar.py:186

    return enclosing_control is not None and [] != [cl for cl in get_locals(enclosing_control) if cl.name == var_name] ## src/utils/codegen.sugar.py:188


var_name_counter = 0 ## src/utils/codegen.sugar.py:191
generated_var_names = set() ## src/utils/codegen.sugar.py:192

def generate_var_name(var_name_part = "var", var_id = None): ## src/utils/codegen.sugar.py:194
    global var_name_counter ## src/utils/codegen.sugar.py:195
    global generated_var_names ## src/utils/codegen.sugar.py:196

    var_name_counter += 1 ## src/utils/codegen.sugar.py:198

    var_name = var_name_part + "_" + str(var_name_counter) ## src/utils/codegen.sugar.py:200
    if var_id is not None: ## src/utils/codegen.sugar.py:201
        simpler_var_name = var_name_part + "_" + var_id ## src/utils/codegen.sugar.py:202
        if simpler_var_name not in generated_var_names: ## src/utils/codegen.sugar.py:203
            var_name = simpler_var_name ## src/utils/codegen.sugar.py:204
        else: ## src/utils/codegen.sugar.py:205
            var_name = simpler_var_name + "_" + str(var_name_counter) ## src/utils/codegen.sugar.py:206

    generated_var_names.add(var_name) ## src/utils/codegen.sugar.py:208

    return var_name ## src/utils/codegen.sugar.py:210

################################################################################ ## src/utils/codegen.sugar.py:212

def int_to_big_endian_byte_array_with_length(value, width, base=10): ## src/utils/codegen.sugar.py:214
    array = [] ## src/utils/codegen.sugar.py:215
    while value > 0: ## src/utils/codegen.sugar.py:216
        array.append(int(value % 256)) ## src/utils/codegen.sugar.py:217
        value /= 256 ## src/utils/codegen.sugar.py:218
    array.reverse() ## src/utils/codegen.sugar.py:219
    array_len = len(array) ## src/utils/codegen.sugar.py:220
    padded_array = [0 for i in range(width-array_len)] + array[array_len-min(array_len, width) : array_len] ## src/utils/codegen.sugar.py:221
    return '{' + ', '.join([print_with_base(x, base) for x in padded_array]) + '}' ## src/utils/codegen.sugar.py:222


def bit_bounding_unit(t): ## src/utils/codegen.sugar.py:225
    """The bit width of the smallest int that can contain the type, ## src/utils/codegen.sugar.py:226
    or the string "bytebuf" if it is larger than all possible container types.""" ## src/utils/codegen.sugar.py:227
    if t.size <= 8: ## src/utils/codegen.sugar.py:228
        return "8" ## src/utils/codegen.sugar.py:229
    if t.size <= 16: ## src/utils/codegen.sugar.py:230
        return "16" ## src/utils/codegen.sugar.py:231
    if t.size <= 32: ## src/utils/codegen.sugar.py:232
        return "32" ## src/utils/codegen.sugar.py:233
    return "bytebuf" ## src/utils/codegen.sugar.py:234

def gen_extern_format_parameter(expr, par, packets_or_bytes_override = None): ## src/utils/codegen.sugar.py:236
    generated_code = ""
    def member_to_field_id(member): ## src/utils/codegen.sugar.py:237
        return 'field_{}_{}'.format(member.expr.type.name, member.member) ## src/utils/codegen.sugar.py:238

    # TODO ## src/utils/codegen.sugar.py:240
    # if packets_or_bytes_override: ## src/utils/codegen.sugar.py:241
    if par.direction == "in" or expr.node_type != "Member": ## src/utils/codegen.sugar.py:242
        prefix = "&" if par.direction != "in" and par.type.node_type != 'Type_Bits' else "" ## src/utils/codegen.sugar.py:243
        generated_code += add_code(' {}({})'.format(prefix, format_expr(expr, format_as_value=True, expand_parameters=True)), 243)
    else: ## src/utils/codegen.sugar.py:245
        expr_width = expr.type.size; ## src/utils/codegen.sugar.py:246

        member = "all_metadatas" if expr.expr.ref.type.type_ref.is_metadata else expr.expr.member if hasattr(expr.expr, 'member') else expr.member ## src/utils/codegen.sugar.py:248

        if expr_width<=32: ## src/utils/codegen.sugar.py:250
            expr_unit = bit_bounding_unit(expr.type) ## src/utils/codegen.sugar.py:251
            prepend_statement(' uint{}_t value_{}; // (prepended) src/utils/codegen.sugar.py:251\n'.format(expr_unit, expr.id)) ## src/utils/codegen.sugar.py:252
            if par.direction=="inout": ## src/utils/codegen.sugar.py:253
                prepend_statement(' value_{} = {}; // (prepended) src/utils/codegen.sugar.py:253\n'.format(expr.id, format_expr(expr))) ## src/utils/codegen.sugar.py:254
            append_statement(' set_field((fldT[]){{{{pd, header_instance_{}, {} }}}}, 0, value_{}, {}); // (appended) src/utils/codegen.sugar.py:254\n'.format(member, member_to_field_id(expr), expr.id, expr_width)) ## src/utils/codegen.sugar.py:255
            generated_code += add_code(' &value_{}'.format(expr.id), 255)
        else: ## src/utils/codegen.sugar.py:257
            prepend_statement(' uint8_t value_{}[{}]; // (prepended) src/utils/codegen.sugar.py:257\n'.format(expr.id, (int)((expr_width+7)/8))) ## src/utils/codegen.sugar.py:258
            if par.direction=="inout": ## src/utils/codegen.sugar.py:259
                prepend_statement(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, {}, value_{}); // (prepended) src/utils/codegen.sugar.py:259\n'.format(member, member_to_field_id(expr), expr.id)) ## src/utils/codegen.sugar.py:260
            append_statement(' MODIFY_BYTEBUF_BYTEBUF_PACKET(pd, header_instance_{}, {}, value_{}, {}); // (appended) src/utils/codegen.sugar.py:260\n'.format(member, member_to_field_id(expr), expr.id, expr_width)) ## src/utils/codegen.sugar.py:261
            generated_code += add_code(' value_{}'.format(expr.id), 261)




    return generated_code

def member_to_field_id(member): ## src/utils/codegen.sugar.py:267
    return 'field_{}_{}'.format(member.expr.type.name, member.member) ## src/utils/codegen.sugar.py:268

def gen_format_statement_fieldref_wide(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id): ## src/utils/codegen.sugar.py:270
    generated_code = ""
    if src.node_type == 'Member': ## src/utils/codegen.sugar.py:271
        src_pointer = 'tmp_fldref_{}'.format(src.id) ## src/utils/codegen.sugar.py:272
        generated_code += add_code(' uint8_t {}[{}];'.format(src_pointer, dst_bytewidth), 272)

        if hasattr(src, 'field_ref'): ## src/utils/codegen.sugar.py:275
            hdrinst = 'all_metadatas' if src.expr.type.is_metadata else src.expr.member ## src/utils/codegen.sugar.py:276
            generated_code += add_code(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, {}, {})'.format(hdrinst, member_to_field_id(src), src_pointer), 276)
            if dst_is_vw: ## src/utils/codegen.sugar.py:278
                src_vw_bitwidth = 'pd->headers[header_instance_{}].var_width_field_bitwidth'.format(src.expr.member) ## src/utils/codegen.sugar.py:279
                dst_bytewidth = '({}/8)'.format(src_vw_bitwidth) ## src/utils/codegen.sugar.py:280
        else: ## src/utils/codegen.sugar.py:281
            srcname = src.expr.ref.name ## src/utils/codegen.sugar.py:282
            generated_code += add_code(' EXTRACT_BYTEBUF_BUFFER(pstate->{}, pstate->{}_var, {}, {})'.format(srcname, srcname, member_to_field_id(src), src_pointer), 282)
            if dst_is_vw: ## src/utils/codegen.sugar.py:284
                src_vw_bitwidth = 'pstate->{}_var'.format(src.expr.ref.name) ## src/utils/codegen.sugar.py:285
                dst_bytewidth = '({}/8)'.format(src_vw_bitwidth) ## src/utils/codegen.sugar.py:286
    elif src.node_type == 'PathExpression': ## src/utils/codegen.sugar.py:287
        refbase = "local_vars->" if is_control_local_var(src.ref.name) else 'parameters.' ## src/utils/codegen.sugar.py:288
        src_pointer = '{}{}'.format(refbase, src.ref.name) ## src/utils/codegen.sugar.py:289
    elif src.node_type == 'Constant': ## src/utils/codegen.sugar.py:290
        src_pointer = 'tmp_fldref_{}'.format(src.id) ## src/utils/codegen.sugar.py:291
        generated_code += add_code(' uint8_t {}[{}] = {};'.format(src_pointer, dst_bytewidth, int_to_big_endian_byte_array_with_length(src.value, dst_bytewidth, src.base)), 291)
    elif src.node_type == 'Mux': ## src/utils/codegen.sugar.py:293
        src_pointer = 'tmp_fldref_{}'.format(src.id) ## src/utils/codegen.sugar.py:294
        generated_code += add_code(' uint8_t {}[{}] = (({}) == ({})) ? ({}) : ({});'.format(src_pointer, dst_bytewidth, format_expr(src.e0.left), format_expr(src.e0.right), format_expr(src.e1), format_expr(src.e2)), 294)
    else: ## src/utils/codegen.sugar.py:296
        src_pointer = 'NOT_SUPPORTED' ## src/utils/codegen.sugar.py:297
        addError('formatting statement', 'Assignment to unsupported field in: {} = {}'.format(format_expr(dst), src)) ## src/utils/codegen.sugar.py:298

    dst_fixed_size = dst.expr.header_ref.type.type_ref.bit_width - dst.field_ref.size ## src/utils/codegen.sugar.py:300

    if dst_is_vw: ## src/utils/codegen.sugar.py:302
        generated_code += add_code(' pd->headers[{}].var_width_field_bitwidth = get_var_width_bitwidth(pstate);'.format(dst_header_id), 302)
        generated_code += add_code(' pd->headers[{}].length = ({} + pd->headers[{}].var_width_field_bitwidth)/8;'.format(dst_header_id, dst_fixed_size, dst_header_id), 303)

    generated_code += add_code(' MODIFY_BYTEBUF_BYTEBUF_PACKET(pd, {}, {}, {}, {})'.format(dst_header_id, dst_field_id, src_pointer, dst_bytewidth), 305)

    generated_code += add_code(' dbg_bytes({}, {},'.format(src_pointer, dst_bytewidth), 307)
    generated_code += add_code("      \"    \" T4LIT(=,field) \" Modifying field \" T4LIT(%s,header) \".\" T4LIT(%s,field) \"/\" T4LIT(%d) \"b (\" T4LIT(%d) \"B) = \",", 308)
    generated_code += add_code('      header_instance_names[{}],'.format(dst_header_id), 309)
    generated_code += add_code('      field_names[{}], // {}'.format(dst_field_id, dst_field_id), 310)
    generated_code += add_code('      {}*8,'.format(dst_bytewidth), 311)
    generated_code += add_code('      {}'.format(dst_bytewidth), 312)
    generated_code += add_code("      );", 313)

    generated_code += add_code(' dbg_bytes(pd->headers[{}].pointer + (160/8), {},'.format(dst_header_id, dst_bytewidth), 315)
    generated_code += add_code("      \"    \" T4LIT(=,field) \" Modifying field \" T4LIT(%s,header) \".\" T4LIT(%s,field) \"/\" T4LIT(%d) \"b (\" T4LIT(%d) \"B) = \",", 316)
    generated_code += add_code('      header_instance_names[{}],'.format(dst_header_id), 317)
    generated_code += add_code('      field_names[{}], // {}'.format(dst_field_id, dst_field_id), 318)
    generated_code += add_code('      {}*8,'.format(dst_bytewidth), 319)
    generated_code += add_code('      {}'.format(dst_bytewidth), 320)
    generated_code += add_code("      );", 321)

    return generated_code

def is_primitive(typenode): ## src/utils/codegen.sugar.py:324
    """Returns true if the argument node is compiled to a non-reference C type.""" ## src/utils/codegen.sugar.py:325
    # TODO determine better if the source is a reference or not ## src/utils/codegen.sugar.py:326
    return typenode.node_type in ["Type_Boolean"] or (typenode.node_type == 'Type_Bits' and typenode.size <= 32) ## src/utils/codegen.sugar.py:327


def gen_format_statement_fieldref_short(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id): ## src/utils/codegen.sugar.py:330
    generated_code = ""
    src_buffer = 'value32' ## src/utils/codegen.sugar.py:331
    if src.node_type == 'Member': ## src/utils/codegen.sugar.py:332
        generated_code += add_code(' {} = {};'.format(src_buffer, format_expr(src)), 332)
    elif src.node_type == 'PathExpression': ## src/utils/codegen.sugar.py:334
        indirection = "&" if is_primitive(src.type) else "" ## src/utils/codegen.sugar.py:335
        refbase = "local_vars->" if is_control_local_var(src.ref.name) else 'parameters.' ## src/utils/codegen.sugar.py:336
        generated_code += add_code(' memcpy(&{}, {}({}{}), {});'.format(src_buffer, indirection, refbase, src.ref.name, dst_bytewidth), 336)
    else: ## src/utils/codegen.sugar.py:338
        generated_code += add_code(' {} = {};'.format(src_buffer, format_expr(src)), 338)


    generated_code += add_code(' // MODIFY_INT32_INT32_AUTO_PACKET(pd, {}, {}, {})'.format(dst_header_id, dst_field_id, src_buffer), 341)
    generated_code += add_code(' set_field((fldT[]){{{{pd, {}, {}}}}}, 0, {}, {});'.format(dst_header_id, dst_field_id, src_buffer, dst_width), 342)


    return generated_code

def gen_format_statement_fieldref(dst, src): ## src/utils/codegen.sugar.py:346
    generated_code = ""
    #TODO: handle preparsed fields, width assignment for vw fields and assignment to buffer instead header fields ## src/utils/codegen.sugar.py:347
    dst_width = dst.type.size ## src/utils/codegen.sugar.py:348
    dst_is_vw = dst.type.node_type == 'Type_Varbits' ## src/utils/codegen.sugar.py:349
    dst_bytewidth = (dst_width+7)/8 ## src/utils/codegen.sugar.py:350

    assert(dst_width == src.type.size) ## src/utils/codegen.sugar.py:352
    assert(dst_is_vw == (src.type.node_type == 'Type_Varbits')) ## src/utils/codegen.sugar.py:353

    dst_name      = dst.expr.member if dst.expr.node_type == 'Member' else dst.expr.path.name if dst.expr('header_ref', lambda h: h.type_ref.is_metadata) else dst.expr._header_ref._path.name ## src/utils/codegen.sugar.py:355
    dst_header_id = "header_instance_all_metadatas" if dst.expr("ref.type.type_ref.is_metadata") else 'header_instance_{}'.format(dst_name) ## src/utils/codegen.sugar.py:356
    dst_field_id  = member_to_field_id(dst) ## src/utils/codegen.sugar.py:357

    if dst_width <= 32: ## src/utils/codegen.sugar.py:359
        generated_code += str( gen_format_statement_fieldref_short(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id)) ## src/utils/codegen.sugar.py:359
    else: ## src/utils/codegen.sugar.py:361
        generated_code += str( gen_format_statement_fieldref_wide(dst, src, dst_width, dst_is_vw, dst_bytewidth, dst_name, dst_header_id, dst_field_id)) ## src/utils/codegen.sugar.py:361



    return generated_code

def is_atomic_block(blckstmt): ## src/utils/codegen.sugar.py:366
    try: ## src/utils/codegen.sugar.py:367
        for annot in blckstmt.annotations.annotations.vec: ## src/utils/codegen.sugar.py:368
            if annot.name == "atomic": ## src/utils/codegen.sugar.py:369
               return True ## src/utils/codegen.sugar.py:370
    except: ## src/utils/codegen.sugar.py:371
        return False ## src/utils/codegen.sugar.py:372
    return False ## src/utils/codegen.sugar.py:373


def gen_do_assignment(dst, src): ## src/utils/codegen.sugar.py:376
    generated_code = ""
    if dst.type.node_type == 'Type_Header': ## src/utils/codegen.sugar.py:377
        generated_code += add_code(" // TODO make it work properly for non-byte-aligned headers", 377)
        if hasattr(dst, "member"): ## src/utils/codegen.sugar.py:379
            if hasattr(src, "member"): ## src/utils/codegen.sugar.py:380
                generated_code += add_code(' memcpy(pd->headers[header_instance_{}].pointer, pd->headers[header_instance_{}].pointer, header_instance_byte_width[header_instance_{}]);'.format(dst.member, src.member, src.member), 380)
                generated_code += add_code(' dbg_bytes(pd->headers[header_instance_{}].pointer, header_instance_byte_width[header_instance_{}], "Copied %02d bytes from header_instance_{} to header_instance_{}: ", header_instance_byte_width[header_instance_{}]);'.format(dst.member, src.member, src.member, dst.member, src.member), 381)
            else: ## src/utils/codegen.sugar.py:383
                addError("Compiling assignment", "Assigning to header instance {} (type {}) from {} ({}) is not supported".format(dst.member, dst.type.name, src.ref.name, src.type.name)) ## src/utils/codegen.sugar.py:384
        else: ## src/utils/codegen.sugar.py:385
            addError("Compiling assignment", "Assigning {} (type {}) from {} ({}) is not supported".format(dst.ref.name, dst.type.name, src.ref.name, src.type.name)) ## src/utils/codegen.sugar.py:386
    elif dst.type.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:387
        # TODO refine the condition to find out whether to use an assignment or memcpy ## src/utils/codegen.sugar.py:388
        requires_memcpy = src.type.size > 32 ## src/utils/codegen.sugar.py:389
        is_assignable = src.type.size in [8, 32] ## src/utils/codegen.sugar.py:390

        if src.type.node_type == 'Type_Bits' and not requires_memcpy: ## src/utils/codegen.sugar.py:392
            if is_assignable: ## src/utils/codegen.sugar.py:393
                # TODO how to decide whether src is a pointer, and therefore needs dereferencing? ## src/utils/codegen.sugar.py:394
                needs_defererencing = src.node_type not in ["Constant"] ## src/utils/codegen.sugar.py:395
                # needs_defererencing = src('field_ref', lambda fr: fr.name == 'meta') ## src/utils/codegen.sugar.py:396
                dereference = "*" if needs_defererencing else "" ## src/utils/codegen.sugar.py:397

                if dst("expr.ref.type.type_ref.is_metadata"): ## src/utils/codegen.sugar.py:399
                    generated_code += add_code(' set_field((fldT[]){{{{pd, header_instance_all_metadatas, field_{}_{}}}}}, 0, ({}({})), {});'.format(dst.expr.ref.type.type_ref.name, dst.member, dereference, format_expr(src, expand_parameters=True), dst.type._type_ref.size), 399)
                    generated_code += add_code(' debug("       : " T4LIT(all_metadatas,header) "." T4LIT({}_{},field) "/" T4LIT(%d) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {}({}), {}({}));'.format(dst.expr.ref.type.type_ref.name, dst.member, (src.type.size+7)/8, dst.type._type_ref.size, dereference, format_expr(src, expand_parameters=True), dereference, format_expr(src, expand_parameters=True)), 400)
                elif dst("header_ref.type.type_ref.is_metadata"): ## src/utils/codegen.sugar.py:402
                    generated_code += add_code(' set_field((fldT[]){{{{pd, header_instance_all_metadatas, field_{}_{}}}}}, 0, ({}({})), {});'.format(dst.header_ref.type.type_ref.name, dst.field_name, dereference, format_expr(src, expand_parameters=True), dst.type._type_ref.size), 402)
                    generated_code += add_code(' debug("       : " T4LIT(all_metadatas,header) "." T4LIT({}_{},field) "/" T4LIT(%d) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {}({}), {}({}));'.format(dst.header_ref.type.type_ref.name, dst.field_name, (src.type.size+7)/8, dst.type._type_ref.size, dereference, format_expr(src, expand_parameters=True), dereference, format_expr(src, expand_parameters=True)), 403)
                else: ## src/utils/codegen.sugar.py:405
                    generated_code += add_code(' {} = ({})({}({}));'.format(format_expr(dst), format_type(dst.type), dereference, format_expr(src, expand_parameters=True)), 405)
                    if dst.node_type == 'Member': ## src/utils/codegen.sugar.py:407
                        if dst.type('is_metadata', lambda ismeta: ismeta): ## src/utils/codegen.sugar.py:408
                            # Note: the metadata header and field name is joined by underscores, separating them as best as possible ## src/utils/codegen.sugar.py:409
                            nameparts = dst.member.split("_") ## src/utils/codegen.sugar.py:410
                            hdr = "_".join(nameparts[1:-1]) ## src/utils/codegen.sugar.py:411
                            fld = nameparts[-1] ## src/utils/codegen.sugar.py:412
                        else: ## src/utils/codegen.sugar.py:413
                            hdr = dst.expr.path.name ## src/utils/codegen.sugar.py:414
                            fld = dst.member ## src/utils/codegen.sugar.py:415
                        generated_code += add_code(' debug("       : " T4LIT({},header) "." T4LIT({},field) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {});'.format(hdr, fld, (src.type.size+7)/8, format_expr(dst), format_expr(dst)), 415)
                    else: ## src/utils/codegen.sugar.py:417
                        generated_code += add_code(' debug("       : " T4LIT({},header) " = " T4LIT(%d,bytes) " (" T4LIT(%{}x,bytes) ")\\n", {}, {});'.format(format_expr(dst), (src.type.size+7)/8, format_expr(dst), format_expr(dst)), 417)
            else: ## src/utils/codegen.sugar.py:419
                tmpvar = generate_var_name() ## src/utils/codegen.sugar.py:420
                generated_code += add_code(' {} {} = {};'.format(format_type(dst.type), tmpvar, format_expr(src, expand_parameters=True)), 420)
                generated_code += add_code(' {} = {};'.format(format_expr(dst), tmpvar), 421)

                # TODO this part should not require memcpy ## src/utils/codegen.sugar.py:424
                # [ ${format_type(dst.type)} $tmpvar = ${format_expr(src, expand_parameters=True)}; ## src/utils/codegen.sugar.py:425
                # [ memcpy(&(${format_expr(dst)}), &$tmpvar, sizeof(${format_type(dst.type)})); ## src/utils/codegen.sugar.py:426
                # TODO debug printout ## src/utils/codegen.sugar.py:427
        else: ## src/utils/codegen.sugar.py:428
            generated_code += add_code(' memcpy(&({}), &({}), {});'.format(format_expr(dst), format_expr(src, expand_parameters=True), dst.type.size), 428)
            generated_code += add_code(' dbg_bytes(&({}), {}, "Copied " T4LIT(%02d) " bytes from {} to {}: ", {});'.format(format_expr(src, expand_parameters=True), dst.type.size, format_expr(src, expand_parameters=True), format_expr(dst), dst.type.size), 429)
    else: ## src/utils/codegen.sugar.py:431
        generated_code += add_code(' {} = {};'.format(format_expr(dst), format_expr(src, expand_parameters=True)), 431)


    return generated_code

def gen_format_statement(stmt): ## src/utils/codegen.sugar.py:435
    generated_code = ""
    global enclosing_control ## src/utils/codegen.sugar.py:436
    if stmt.node_type == 'AssignmentStatement': ## src/utils/codegen.sugar.py:437
        dst = stmt.left ## src/utils/codegen.sugar.py:438
        src = stmt.right ## src/utils/codegen.sugar.py:439
        if hasattr(dst, 'field_ref'): ## src/utils/codegen.sugar.py:440
            generated_code += str( gen_format_statement_fieldref(dst, src)) ## src/utils/codegen.sugar.py:440
        else: ## src/utils/codegen.sugar.py:442
            generated_code += str( gen_do_assignment(dst, src)) ## src/utils/codegen.sugar.py:442
    elif stmt.node_type == 'BlockStatement': ## src/utils/codegen.sugar.py:444
        is_atomic = is_atomic_block(stmt) ## src/utils/codegen.sugar.py:445
        if is_atomic: ## src/utils/codegen.sugar.py:446
            generated_code += add_code(' LOCK(&{}_lock)'.format(enclosing_control.type.name), 446)
        for c in stmt.components: ## src/utils/codegen.sugar.py:448
            generated_code += str( gen_format_statement(c)) ## src/utils/codegen.sugar.py:448
        if is_atomic: ## src/utils/codegen.sugar.py:450
            generated_code += add_code(' UNLOCK(&{}_lock)'.format(enclosing_control.type.name), 450)
    elif stmt.node_type == 'IfStatement': ## src/utils/codegen.sugar.py:452
        t = format_statement(stmt.ifTrue) if hasattr(stmt, 'ifTrue') else ';' ## src/utils/codegen.sugar.py:453
        f = format_statement(stmt.ifFalse) if hasattr(stmt, 'ifFalse') else ';' ## src/utils/codegen.sugar.py:454
        cond = format_expr(stmt.condition) ## src/utils/codegen.sugar.py:455

        # TODO this happens when .hit() is called; make a proper solution ## src/utils/codegen.sugar.py:457
        if cond.strip() == '': ## src/utils/codegen.sugar.py:458
            cond = "true" ## src/utils/codegen.sugar.py:459

        generated_code += add_code(' if( {} ) {{'.format(cond), 460)
        generated_code += add_code('     {}'.format(t), 461)
        generated_code += add_code("", 462)
        generated_code += add_code(" } else {", 463)
        generated_code += add_code('     {}'.format(f), 464)
        generated_code += add_code(" }", 465)
    elif stmt.node_type == 'MethodCallStatement': ## src/utils/codegen.sugar.py:467
        m = stmt.methodCall.method ## src/utils/codegen.sugar.py:468

        if m.node_type == 'Method' and m.name == 'digest': ## src/utils/codegen.sugar.py:470
            return gen_format_methodcall_digest(stmt, m) ## src/utils/codegen.sugar.py:471
        else: ## src/utils/codegen.sugar.py:472
            if m.get_attr('member') is not None: ## src/utils/codegen.sugar.py:473
                return gen_format_expr_methodcall(stmt, m) ## src/utils/codegen.sugar.py:474
            else: ## src/utils/codegen.sugar.py:475
                generated_code += str( gen_methodcall(stmt)) ## src/utils/codegen.sugar.py:475
    elif stmt.node_type == 'SwitchStatement': ## src/utils/codegen.sugar.py:477
        generated_code += add_code(' switch({}) {{'.format(format_expr(stmt.expression)), 477)
        for case in stmt.cases: ## src/utils/codegen.sugar.py:479
            if case.label.node_type == "DefaultExpression": ## src/utils/codegen.sugar.py:480
                generated_code += add_code(" default:", 480)
            else: ## src/utils/codegen.sugar.py:482
                generated_code += add_code(' case {}:'.format(format_expr(case.label)), 482)
            generated_code += add_code('   {}'.format(format_statement(case.statement)), 483)
            generated_code += add_code("   break;", 484)
        if [case for case in stmt.cases if case.label.node_type == "DefaultExpression"] == []: ## src/utils/codegen.sugar.py:486
            generated_code += add_code("   default: {}", 486)
        generated_code += add_code(" }", 487)

    return generated_code

def gen_format_methodcall_digest(stmt, m): ## src/utils/codegen.sugar.py:490
    generated_code = ""
    digest_name = stmt.methodCall.typeArguments[0].name ## src/utils/codegen.sugar.py:491
    port, fields = stmt.methodCall.arguments ## src/utils/codegen.sugar.py:492

    generated_code += add_code(" struct type_field_list fields;", 493)
    generated_code += add_code(' fields.fields_quantity = {};'.format(len(fields)), 494)
    generated_code += add_code(" fields.field_offsets = malloc(sizeof(uint8_t*)*fields.fields_quantity);", 495)
    generated_code += add_code(" fields.field_widths = malloc(sizeof(uint8_t*)*fields.fields_quantity);", 496)

    for idx, f in enumerate(fields.components): ## src/utils/codegen.sugar.py:499
        if f.expr.type.is_metadata: ## src/utils/codegen.sugar.py:500
            generated_code += add_code(' fields.field_offsets[{}] = (uint8_t*) field_desc(pd, field_instance_{}_{}).byte_addr;'.format(idx, f.expr.name, f.member), 500)
            generated_code += add_code(' fields.field_widths[{}]  =            field_desc(pd, field_instance_{}_{}).bitwidth;'.format(idx, f.expr.name, f.member), 501)
        else: ## src/utils/codegen.sugar.py:503
            generated_code += add_code(' fields.field_offsets[{}] = (uint8_t*) field_desc(pd, field_instance_{}_{}).byte_addr;'.format(idx, f.expr.member, f.expression.field_ref.name), 503)
            generated_code += add_code(' fields.field_widths[{}]  =            field_desc(pd, field_instance_{}_{}).bitwidth;'.format(idx, f.expr.member, f.expression.field_ref.name), 504)
    generated_code += add_code(' generate_digest(bg,"{}",0,&fields);'.format(digest_name), 505)
    generated_code += add_code(" sleep_millis(DIGEST_SLEEP_MILLIS);", 506)

    return generated_code

def is_emit(stmt, m): ## src/utils/codegen.sugar.py:509
    return m.expr._ref('type')._type_ref('name', lambda n: n == 'packet_out') ## src/utils/codegen.sugar.py:510

def gen_format_expr_methodcall(stmt, m): ## src/utils/codegen.sugar.py:512
    generated_code = ""
    if is_emit(stmt, m): ## src/utils/codegen.sugar.py:513
        arg = stmt.methodCall.arguments[0] ## src/utils/codegen.sugar.py:514
        hdr = arg.expression.member ## src/utils/codegen.sugar.py:515
        hdr_type = arg.expression.type ## src/utils/codegen.sugar.py:516

        hdr_name = arg.expression.header_ref.name if hasattr(arg.expression, 'header_ref') else arg.expression.member ## src/utils/codegen.sugar.py:518

        generated_code += add_code(' pd->header_reorder[pd->emit_hdrinst_count] = header_instance_{};'.format(hdr), 519)
        generated_code += add_code(" ++pd->emit_hdrinst_count;", 520)
    elif (m.expr.node_type, m.expr('ref').node_type, m.member) == ('PathExpression', 'P4Table', 'apply'): ## src/utils/codegen.sugar.py:522
        generated_code += add_code(' {};'.format(gen_method_apply(stmt.methodCall)), 522)
    elif m.expr.get_attr('member') is None: ## src/utils/codegen.sugar.py:524
        return gen_format_expr_methodcall_extern(stmt, m) ## src/utils/codegen.sugar.py:525
    else: ## src/utils/codegen.sugar.py:526
        hdr_name = m.expr.member ## src/utils/codegen.sugar.py:527

        if m.member == 'isValid': ## src/utils/codegen.sugar.py:529
            generated_code += add_code(' controlLocal_tmp_0 = (pd->headers[header_instance_{}].pointer != NULL);'.format(hdr_name), 529)
        elif m.member == 'setValid': ## src/utils/codegen.sugar.py:531
            generated_code += add_code(' if (likely(pd->headers[header_instance_{}].pointer == NULL)) {{'.format(hdr_name), 531)
            generated_code += add_code('    pd->headers[header_instance_{}].pointer = (pd->header_tmp_storage + header_instance_infos[header_instance_{}].byte_offset);'.format(hdr_name, hdr_name), 532)
            generated_code += add_code("    pd->is_emit_reordering = true;", 533)
            generated_code += add_code('    debug("   :: Header instance " T4LIT({},header) "/" T4LIT(%d) "B set as " T4LIT(valid,success) "\\n", pd->headers[header_instance_{}].length);'.format(hdr_name, hdr_name), 534)
            generated_code += add_code(" } else {", 535)
            generated_code += add_code('    debug("   " T4LIT(!!,warning) " Trying to set header instance " T4LIT({},header) " to " T4LIT(valid,success) ", but it is already " T4LIT(valid,success) "\\n");'.format(hdr_name), 536)
            generated_code += add_code(" }", 537)
        elif m.member == 'setInvalid': ## src/utils/codegen.sugar.py:539
            generated_code += add_code(' if (likely(pd->headers[header_instance_{}].pointer != NULL)) {{'.format(hdr_name), 539)
            generated_code += add_code('    pd->headers[header_instance_{}].pointer = NULL;'.format(hdr_name), 540)
            generated_code += add_code("    pd->is_emit_reordering = true;", 541)
            generated_code += add_code('    debug("   :: Header instance " T4LIT({},header) "/" T4LIT(%d) "B set as " T4LIT(invalid,status) "\\n", pd->headers[header_instance_{}].length);'.format(hdr_name, hdr_name), 542)
            generated_code += add_code(" } else {", 543)
            generated_code += add_code('    debug("   " T4LIT(!!,warning) " Trying to set header instance " T4LIT({},header) " to " T4LIT(valid,success) ", but it is already " T4LIT(valid,success) "\\n");'.format(hdr_name), 544)
            generated_code += add_code(" }", 545)
        else: ## src/utils/codegen.sugar.py:547
            generated_code += str( gen_methodcall(stmt)) ## src/utils/codegen.sugar.py:547

    return generated_code

def gen_format_expr_methodcall_extern(stmt, m): ## src/utils/codegen.sugar.py:550
    generated_code = ""
    smem_type = m.expr.type._baseType.name ## src/utils/codegen.sugar.py:551

    # if the extern is about both packets and bytes, it takes two separate calls ## src/utils/codegen.sugar.py:553
    is_possibly_multiple = smem_type in ["counter", "meter", "direct_counter", "direct_meter"] ## src/utils/codegen.sugar.py:554
    if is_possibly_multiple: ## src/utils/codegen.sugar.py:555
        if m.expr.ref.packets_or_bytes == "packets_and_bytes": ## src/utils/codegen.sugar.py:556
            generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, "packets")) ## src/utils/codegen.sugar.py:556
            generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, "bytes")) ## src/utils/codegen.sugar.py:557
        else: ## src/utils/codegen.sugar.py:559
            generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, m.expr.ref.packets_or_bytes)) ## src/utils/codegen.sugar.py:559
    else: ## src/utils/codegen.sugar.py:561
        generated_code += str( gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple)) ## src/utils/codegen.sugar.py:561


    return generated_code

def gen_format_extern_single(stmt, m, smem_type, is_possibly_multiple, packets_or_bytes = None): ## src/utils/codegen.sugar.py:565
    generated_code = ""
    mexpr_type = m.expr.type ## src/utils/codegen.sugar.py:566

    if m.expr.type.node_type == "Type_SpecializedCanonical": ## src/utils/codegen.sugar.py:568
        mexpr_type = mexpr_type.substituted ## src/utils/codegen.sugar.py:569

    parameters = stmt.methodCall.method.type.parameters.parameters ## src/utils/codegen.sugar.py:571

    method_args = zip(stmt.methodCall.arguments, parameters) ## src/utils/codegen.sugar.py:573

    mprefix = "global_smem." ## src/utils/codegen.sugar.py:575
    mname = mprefix + m.expr.path.name ## src/utils/codegen.sugar.py:576
    mparname = mname ## src/utils/codegen.sugar.py:577

    if smem_type in ["counter", "meter"]: ## src/utils/codegen.sugar.py:579
        mname = "{}{}_{}_{}".format(mprefix, smem_type, m.expr.path.name, packets_or_bytes) ## src/utils/codegen.sugar.py:580
        mparname = mname ## src/utils/codegen.sugar.py:581
    if smem_type in ["direct_counter", "direct_meter"]: ## src/utils/codegen.sugar.py:582
        mname = "{}{}_{}_{}_{}".format(mprefix, smem_type, m.expr.path.name, packets_or_bytes, "TODO_table") ## src/utils/codegen.sugar.py:583
        mparname = mname ## src/utils/codegen.sugar.py:584

    packets_or_bytes_override = None ## src/utils/codegen.sugar.py:586
    if method_args != []: ## src/utils/codegen.sugar.py:587
        (expr, par) = method_args[0] ## src/utils/codegen.sugar.py:588
        if m.expr.ref._packets_or_bytes == "packets_and_bytes": ## src/utils/codegen.sugar.py:589
            packets_or_bytes_override = packets_or_bytes ## src/utils/codegen.sugar.py:590

    if m.expr.type.node_type == "Type_Extern": ## src/utils/codegen.sugar.py:592
        # TODO support parameters of type Type_List (e.g. in InternetChecksum in the example psa-l3fwd-with-chksm) ## src/utils/codegen.sugar.py:593
        stypename = stmt.methodCall.method.expr.type.name ## src/utils/codegen.sugar.py:594
        paramtypes = ['{}_t*'.format(stypename) if idx == 0 else gen_format_type(arg[0].expression.type) for idx, arg in enumerate(method_args)] ## src/utils/codegen.sugar.py:595
    elif m.expr.type.node_type == "Type_SpecializedCanonical": ## src/utils/codegen.sugar.py:596
        method_args = method_args[1:] ## src/utils/codegen.sugar.py:597

        if hasattr(expr.expression, 'name'): ## src/utils/codegen.sugar.py:599
            paramtype = "struct " + expr.expression.name ## src/utils/codegen.sugar.py:600
        elif expr.expression.type.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:601
            paramtype = format_type(expr.expression.type) ## src/utils/codegen.sugar.py:602
        elif expr.expression.node_type == 'Constant': ## src/utils/codegen.sugar.py:603
            paramtype = format_type(expr.expression.type) ## src/utils/codegen.sugar.py:604
        elif m.expr.ref.type.baseType.type_ref.node_type == 'Type_Extern': ## src/utils/codegen.sugar.py:605
            paramtype = m.expr.type.arguments[0].name ## src/utils/codegen.sugar.py:606
        else: ## src/utils/codegen.sugar.py:607
            paramtype = "int/*temporarily inserted for unknown type*/" ## src/utils/codegen.sugar.py:608
            addWarning('generating method call statement', 'Unexpected type {} in {}'.format(m.expr.type, stmt.methodCall)) ## src/utils/codegen.sugar.py:609

        if is_possibly_multiple and hasattr(expr.expression.type, 'fields'): ## src/utils/codegen.sugar.py:611
            tmpvar = generate_var_name() ## src/utils/codegen.sugar.py:612
            generated_code += add_code(' {} {} = {};'.format(paramtype, tmpvar, gen_extern_format_parameter(expr, par, packets_or_bytes_override)), 612)

            for fld, component in zip(expr.expression.type.fields, stmt.methodCall.arguments[0].expression.components): ## src/utils/codegen.sugar.py:615
                ce = component.expression ## src/utils/codegen.sugar.py:616

                if fld.type.size <= 32: ## src/utils/codegen.sugar.py:618
                    generated_code += add_code(' dbg_bytes(&({}.{}), ({}+7)/8, "       : " T4LIT({},header) "." T4LIT({},field) " = ");'.format(tmpvar, fld.name, fld.type.size, format_expr(ce.expr), ce.member), 618)
                    continue ## src/utils/codegen.sugar.py:620

                hdr = ce.expr.header_ref.name ## src/utils/codegen.sugar.py:622

                generated_code += add_code(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, field_instance_{}_{}, &({}.{}));'.format(hdr, hdr, ce.field_ref.name, tmpvar, fld.name), 623)
                generated_code += add_code(' dbg_bytes(&({}.{}), ({}+7)/8, "       : " T4LIT({},header) "." T4LIT({},field) " = ");'.format(tmpvar, fld.name, fld.type.size, hdr, ce.field_ref.name), 624)

            generated_code += add_code(' memcpy(&({}), &{}, sizeof({}));'.format(mname, tmpvar, paramtype), 626)

        paramtypes = [paramtype] ## src/utils/codegen.sugar.py:629


    def resolve_type(t, type_params): ## src/utils/codegen.sugar.py:632
        return type_params[t.name] if t.node_type == 'Type_Var' else t ## src/utils/codegen.sugar.py:633

    extern_param_indexes = { ## src/utils/codegen.sugar.py:635
        ('meter',        'execute_meter'): ([1]), ## src/utils/codegen.sugar.py:636
        ('register',     'read'):          ([0]), ## src/utils/codegen.sugar.py:637
        ('register',     'write'):         ([1]), ## src/utils/codegen.sugar.py:638
        ('Digest',       'pack'):          ([0]), ## src/utils/codegen.sugar.py:639
    } ## src/utils/codegen.sugar.py:640

    base_type = m.expr.ref.type ## src/utils/codegen.sugar.py:642
    if hasattr(base_type, 'baseType'): ## src/utils/codegen.sugar.py:643
        base_type = base_type.baseType ## src/utils/codegen.sugar.py:644

    extern_type = base_type.type_ref.name ## src/utils/codegen.sugar.py:646

    type_param_names = [t.name for t in stmt.methodCall.method.type.typeParameters.parameters] ## src/utils/codegen.sugar.py:648
    type_params = dict(zip(type_param_names, stmt.methodCall.typeArguments)) ## src/utils/codegen.sugar.py:649
    param_indexes = extern_param_indexes[(extern_type, m.member)] if (extern_type, m.member) in extern_param_indexes else [] ## src/utils/codegen.sugar.py:650
    types = [m.type.parameters.parameters[par].type for par in param_indexes] ## src/utils/codegen.sugar.py:651

    # the indexes of the parameters which originate from a type parameter ## src/utils/codegen.sugar.py:653
    # TODO generalize and move to hlir16_attrs ## src/utils/codegen.sugar.py:654
    default_extern_opts = (True, [], None, None) ## src/utils/codegen.sugar.py:655
    # TODO add a way to issue compile time/runtime warnings (addWarning), e.g. if there is a buffer overflow ## src/utils/codegen.sugar.py:656

    externs = { ## src/utils/codegen.sugar.py:658
        ('bytes',   'meter',        'execute_meter'): ( True, [],        ["{0}", "{2}", "{3}"],            ["{0}[(uint32_t)({1}) - 1]", "*((uint32_t*)({2}))"]), ## src/utils/codegen.sugar.py:659
        ('packets', 'counter',      'count'):         ( True, [],        ["{0}", "int", "uint32_t"],       ["{0}[(uint32_t)({1}) - 1]", "{1}", "1"]), ## src/utils/codegen.sugar.py:660
        ('bytes',   'counter',      'count'):         ( True, [],        ["{0}", "int", "uint32_t"],       ["REPLACED_BELOW"]), ## src/utils/codegen.sugar.py:661
        (None,      'register',     'read'):          ( True, ["&({})"], ["register_{0}*", "{1}*", "{2}"], None), ## src/utils/codegen.sugar.py:662
        (None,      'register',     'write'):         ( True, ["{}"],    ["register_{0}*", "int", "{2}"],  ["{0}[(uint32_t)({1}) - 1]", "(int)({1})", "{2}"]), ## src/utils/codegen.sugar.py:663
        (None,      'Digest',       'pack'):          (False, [],        ["{1}*"],                         None), ## src/utils/codegen.sugar.py:664
    } ## src/utils/codegen.sugar.py:665

    extern_params = (packets_or_bytes, extern_type, m.member) ## src/utils/codegen.sugar.py:667
    type_args_in_fun_name, expr_args, type_par_reformat, arg_reformat = externs[extern_params] if extern_params in externs else default_extern_opts ## src/utils/codegen.sugar.py:668

    if packets_or_bytes == 'bytes': ## src/utils/codegen.sugar.py:670
        varname = generate_var_name("packet_size_bytes"); ## src/utils/codegen.sugar.py:671
        prepend_statement(' uint32_t {} = pd->parsed_length; // (prepended) src/utils/codegen.sugar.py:671\n'.format(varname)) ## src/utils/codegen.sugar.py:672
        arg_reformat = ["{0}[(uint32_t)({1}) - 1]", "{1}", varname] ## src/utils/codegen.sugar.py:673


    if expr_args != []: ## src/utils/codegen.sugar.py:676
        ee = expr.expression ## src/utils/codegen.sugar.py:677
        # TODO if 'meta', use the appropriate field of all_metadatas ## src/utils/codegen.sugar.py:678
        local_name = str(ee.value) if ee.node_type == "Constant" else mprefix + ee.member if ee._expr.path.name == 'meta' else mprefix + ee.path.name ## src/utils/codegen.sugar.py:679
        expr_args = [earg.format(local_name) for earg in expr_args] ## src/utils/codegen.sugar.py:680

    type_params2 = paramtypes + [format_type(resolve_type(par.type, type_params)) for par in parameters] ## src/utils/codegen.sugar.py:682
    if type_par_reformat is not None: ## src/utils/codegen.sugar.py:683
        type_params2 = [fmt.format(*type_params2) for fmt in type_par_reformat] ## src/utils/codegen.sugar.py:684
    type_params_str = ", ".join(type_params2) ## src/utils/codegen.sugar.py:685

    type_args = "".join(["_" + format_type(resolve_type(t, type_params)) for t in types]) ## src/utils/codegen.sugar.py:687

    with SugarStyle("inline_comment"): ## src/utils/codegen.sugar.py:689
        param_args = [gen_extern_format_parameter(arg.expression, par) for (arg, par) in method_args] ## src/utils/codegen.sugar.py:690

    all_args = [mparname] + expr_args + param_args ## src/utils/codegen.sugar.py:692

    if arg_reformat is not None: ## src/utils/codegen.sugar.py:694
        all_args = [fmt.format(*all_args) for fmt in arg_reformat] ## src/utils/codegen.sugar.py:695
    all_args = ["&({})".format(all_args[0])] + all_args[1:] ## src/utils/codegen.sugar.py:696
    all_args = ", ".join(all_args) ## src/utils/codegen.sugar.py:697

    funname_postfix = type_args if type_args_in_fun_name else "" ## src/utils/codegen.sugar.py:699

    prepend_statement(' extern void extern_{}_{}{}({}); // (prepended) src/utils/codegen.sugar.py:700\n'.format(mexpr_type.name, m.member, funname_postfix, type_params_str)) ## src/utils/codegen.sugar.py:701
    generated_code += add_code(' extern_{}_{}{}({});'.format(mexpr_type.name, m.member, funname_postfix, all_args), 701)



    return generated_code

def gen_methodcall(stmt): ## src/utils/codegen.sugar.py:706
    generated_code = ""
    mcall = format_expr(stmt.methodCall) ## src/utils/codegen.sugar.py:707

    if mcall: ## src/utils/codegen.sugar.py:709
        generated_code += add_code(' {};'.format(mcall), 709)
    else: ## src/utils/codegen.sugar.py:711
        addWarning('generating method call statement', 'Invalid method call {}'.format(stmt.methodCall)) ## src/utils/codegen.sugar.py:712
        generated_code += add_code(' /* unhandled method call {} */'.format(stmt.methodCall), 712)


    return generated_code

################################################################################ ## src/utils/codegen.sugar.py:716

def resolve_reference(e): ## src/utils/codegen.sugar.py:718
    if hasattr(e, 'field_ref'): ## src/utils/codegen.sugar.py:719
        h = e.expr.header_ref ## src/utils/codegen.sugar.py:720
        f = e.field_ref ## src/utils/codegen.sugar.py:721
        return (h, f) ## src/utils/codegen.sugar.py:722
    else: ## src/utils/codegen.sugar.py:723
        return e ## src/utils/codegen.sugar.py:724

def is_subsequent((h1, f1), (h2, f2)): ## src/utils/codegen.sugar.py:726
    fs = h1.type.type_ref.fields.vec ## src/utils/codegen.sugar.py:727
    return h1 == h2 and fs.index(f1) + 1 == fs.index(f2) ## src/utils/codegen.sugar.py:728

def groupby(xs, fun): ## src/utils/codegen.sugar.py:730
    """Groups the elements of a list. ## src/utils/codegen.sugar.py:731
    The upcoming element will be grouped if ## src/utils/codegen.sugar.py:732
    fun(last element of the group, upcoming) evaluates to true.""" ## src/utils/codegen.sugar.py:733
    if not xs: ## src/utils/codegen.sugar.py:734
        yield [] ## src/utils/codegen.sugar.py:735
        return ## src/utils/codegen.sugar.py:736

    elems = [] ## src/utils/codegen.sugar.py:738
    for x in xs: ## src/utils/codegen.sugar.py:739
        if elems == []: ## src/utils/codegen.sugar.py:740
            elems = [x] ## src/utils/codegen.sugar.py:741
        elif not fun(elems[-1], x): ## src/utils/codegen.sugar.py:742
            yield elems ## src/utils/codegen.sugar.py:743
            elems = [x] ## src/utils/codegen.sugar.py:744
        else: ## src/utils/codegen.sugar.py:745
            elems.append(x) ## src/utils/codegen.sugar.py:746

    if elems != []: ## src/utils/codegen.sugar.py:748
        yield elems ## src/utils/codegen.sugar.py:749

def group_references(refs): ## src/utils/codegen.sugar.py:751
    for xs in groupby(refs, lambda x1, x2: isinstance(x1, tuple) and isinstance(x2, tuple) and is_subsequent(x1, x2)): ## src/utils/codegen.sugar.py:752
        if xs == [None]: ## src/utils/codegen.sugar.py:753
            # TODO investigate this case further ## src/utils/codegen.sugar.py:754
            continue ## src/utils/codegen.sugar.py:755
        
        yield (xs[0][0], map(lambda (hdr, fld): fld, xs)) ## src/utils/codegen.sugar.py:757

def fldid(h, f): ## src/utils/codegen.sugar.py:759
    inst_type_name = 'all_metadatas' if h._type._type_ref.is_metadata else h.ref.name if h.node_type == 'PathExpression' else h.name ## src/utils/codegen.sugar.py:760
    return 'field_instance_{}_{}'.format(inst_type_name, f.name) ## src/utils/codegen.sugar.py:761
def fldid2(h, f): return h.id + ',' +  f.id ## src/utils/codegen.sugar.py:762


# A set of expression IDs that have already been generated. ## src/utils/codegen.sugar.py:765
generated_exprs = set() ## src/utils/codegen.sugar.py:766

def convert_component(component): ## src/utils/codegen.sugar.py:768
    if component.node_type == 'Member': ## src/utils/codegen.sugar.py:769
        hdr      = component.expr ## src/utils/codegen.sugar.py:770
        fld_name = component.member ## src/utils/codegen.sugar.py:771
        fld      = hdr.type.fields.get(fld_name) ## src/utils/codegen.sugar.py:772
        return (component.node_type, hdr, fld) ## src/utils/codegen.sugar.py:773

    if component.node_type == 'Constant': ## src/utils/codegen.sugar.py:775
        return (component.node_type, component.value, "") ## src/utils/codegen.sugar.py:776

    addWarning('generating list expression buffer', 'Skipping not supported list element %s' % component) ## src/utils/codegen.sugar.py:778
    return None ## src/utils/codegen.sugar.py:779

def listexpression_to_buf(expr): ## src/utils/codegen.sugar.py:781
    def width(hdr, fld): ## src/utils/codegen.sugar.py:782
        if fld.is_vw: return 'field_desc(pd, %s).bitwidth'%fldid(hdr, fld) ## src/utils/codegen.sugar.py:783
        return str(fld.size) ## src/utils/codegen.sugar.py:784

    s = "" ## src/utils/codegen.sugar.py:786
    o = '0' ## src/utils/codegen.sugar.py:787
    # TODO add support for component.node_type == 'Constant' ## src/utils/codegen.sugar.py:788
    components = [('tuple', c[0], c[1]) if type(c) == tuple else convert_component(c) for c in map(resolve_reference, expr.components)] ## src/utils/codegen.sugar.py:789
    components = [(c[1], c[2]) for c in components if c is not None if c[0] != 'Constant'] ## src/utils/codegen.sugar.py:790
    for h, fs in group_references(components): ## src/utils/codegen.sugar.py:791
        w = '+'.join([width(h, f) for f in fs]) ## src/utils/codegen.sugar.py:792
        s += 'memcpy(buffer%s + (%s+7)/8, field_desc(pd, %s).byte_addr, (%s+7)/8);\n' % (expr.id, o, fldid(h, fs[0]), w) ## src/utils/codegen.sugar.py:793
        o += '+'+w ## src/utils/codegen.sugar.py:794
    return 'int buffer{0}_size = ({1}+7)/8;\nuint8_t buffer{0}[buffer{0}_size];\n'.format(expr.id, o) + s ## src/utils/codegen.sugar.py:795

################################################################################ ## src/utils/codegen.sugar.py:797

def gen_method_isValid(e): ## src/utils/codegen.sugar.py:799
    generated_code = ""
    if hasattr(e.method.expr, 'header_ref'): ## src/utils/codegen.sugar.py:800
        generated_code += add_code(' (pd->headers[{}].pointer != NULL)'.format(e.method.expr.header_ref.id), 800)
    else: ## src/utils/codegen.sugar.py:802
        generated_code += add_code(' (pd->headers[{}].pointer != NULL)'.format(format_expr(e.method.expr)), 802)

    return generated_code

def gen_method_setInvalid(e): ## src/utils/codegen.sugar.py:805
    generated_code = ""
    if hasattr(e.method.expr, 'header_ref'): ## src/utils/codegen.sugar.py:806
        generated_code += add_code(' pd->headers[{}].pointer = NULL'.format(e.method.expr.header_ref.id), 806)
    else: ## src/utils/codegen.sugar.py:808
        generated_code += add_code(' pd->headers[{}].pointer = NULL'.format(format_expr(e.method.expr)), 808)

    return generated_code

def gen_method_apply(e): ## src/utils/codegen.sugar.py:811
    generated_code = ""
    generated_code += add_code(' {}_apply(STDPARAMS_IN)'.format(e.method.expr.path.name), 811)

    return generated_code

def gen_method_setValid(e): ## src/utils/codegen.sugar.py:814
    generated_code = ""
    h = e.method.expr.header_ref ## src/utils/codegen.sugar.py:815

    # TODO fix: f must always have an is_vw attribute ## src/utils/codegen.sugar.py:817
    def is_vw(f): ## src/utils/codegen.sugar.py:818
        if f.get_attr('is_vw') is None: ## src/utils/codegen.sugar.py:819
            return False ## src/utils/codegen.sugar.py:820
        return f.is_vw ## src/utils/codegen.sugar.py:821

    # TODO is this the max size? ## src/utils/codegen.sugar.py:823
    length = (sum([f.size if not is_vw(f) else 0 for f in h.type.type_ref.fields])+7)/8 ## src/utils/codegen.sugar.py:824

    generated_code += add_code(' pd->headers[{}] = (header_descriptor_t) {{'.format(h.id), 825)
    generated_code += add_code('     .type = {},'.format(h.id), 826)
    generated_code += add_code('     .length = {},'.format(length), 827)
    generated_code += add_code('     .pointer = calloc({}, sizeof(uint8_t)),'.format(h.type.type_ref.byte_width), 828)
    generated_code += add_code("     /*TODO determine and set this field*/", 829)
    generated_code += add_code("     .var_width_field_bitwidth = 0,", 830)
    generated_code += add_code(" };", 831)

    return generated_code

def print_with_base(number, base): ## src/utils/codegen.sugar.py:834
    if base == 16: ## src/utils/codegen.sugar.py:835
        return "0x{0:x}".format(number) ## src/utils/codegen.sugar.py:836
    if base == 2: ## src/utils/codegen.sugar.py:837
        return "0b{0:b}".format(number) ## src/utils/codegen.sugar.py:838

    return "{}".format(number) ## src/utils/codegen.sugar.py:840

def gen_format_expr(e, format_as_value=True, expand_parameters=False): ## src/utils/codegen.sugar.py:842
    generated_code = ""
    simple_binary_ops = {'Div':'/', 'Mod':'%',                                 #Binary arithmetic operators ## src/utils/codegen.sugar.py:843
                         'Grt':'>', 'Geq':'>=', 'Lss':'<', 'Leq':'<=',         #Binary comparison operators ## src/utils/codegen.sugar.py:844
                         'BAnd':'&', 'BOr':'|', 'BXor':'^',                    #Bitwise operators ## src/utils/codegen.sugar.py:845
                         'LAnd':'&&', 'LOr':'||',                              #Boolean operators ## src/utils/codegen.sugar.py:846
                         'Equ':'==', 'Neq':'!='}                               #Equality operators ## src/utils/codegen.sugar.py:847

    # TODO currently, AddSat and SubSat are handled exactly as Add and Sub ## src/utils/codegen.sugar.py:849
    complex_binary_ops = {'AddSat':'+', 'SubSat':'-', 'Add':'+', 'Sub':'-', 'Mul':'*', 'Shl':'<<', 'Shr':'>>'} ## src/utils/codegen.sugar.py:850

    if e is None: ## src/utils/codegen.sugar.py:852
        return "FORMAT_EXPR(None)" ## src/utils/codegen.sugar.py:853
    elif e.node_type == 'DefaultExpression': ## src/utils/codegen.sugar.py:854
        return "default" ## src/utils/codegen.sugar.py:855
    elif e.node_type == 'Parameter': ## src/utils/codegen.sugar.py:856
        return format_type(e.type) + " " + e.name ## src/utils/codegen.sugar.py:857
    elif e.node_type == 'Constant': ## src/utils/codegen.sugar.py:858
        if e.type.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:859
            if e.type.size > 32: ## src/utils/codegen.sugar.py:860
                def split_text(text, n): ## src/utils/codegen.sugar.py:861
                    """Splits the text into chunks that are n characters long.""" ## src/utils/codegen.sugar.py:862
                    return [text[i:i+n] for i in range(0, len(text), n)] ## src/utils/codegen.sugar.py:863

                byte_width = (e.type.size+7)/8 ## src/utils/codegen.sugar.py:865
                const_str_format = '{:0' + str(2 * byte_width) + 'x}' ## src/utils/codegen.sugar.py:866
                const_str = const_str_format.format(e.value) ## src/utils/codegen.sugar.py:867
                array_const = ", ".join(["0x" + txt for txt in split_text(const_str, 2)]) ## src/utils/codegen.sugar.py:868
                var_name = generate_var_name("const", "0x" + const_str) ## src/utils/codegen.sugar.py:869

                prepend_statement(' uint8_t {}[] = {{{}}}; // (prepended) src/utils/codegen.sugar.py:870\n'.format(var_name, array_const)) ## src/utils/codegen.sugar.py:871

                return var_name ## src/utils/codegen.sugar.py:873
            else: ## src/utils/codegen.sugar.py:874
                value_hint = "" if e.type.size <= 4 or e.value < 2**(e.type.size-1) else " /* probably -{} */".format(2**e.type.size - e.value) ## src/utils/codegen.sugar.py:875
                # 4294967136 versus (uint32_t)4294967136 ## src/utils/codegen.sugar.py:876
                return "({}){}{}".format(format_type(e.type), print_with_base(e.value, e.base), value_hint) ## src/utils/codegen.sugar.py:877
        else: ## src/utils/codegen.sugar.py:878
            return str(e.value) ## src/utils/codegen.sugar.py:879
    elif e.node_type == 'BoolLiteral': ## src/utils/codegen.sugar.py:880
        return 'true' if e.value else 'false' ## src/utils/codegen.sugar.py:881
    elif e.node_type == 'StringLiteral': ## src/utils/codegen.sugar.py:882
        return '"' + e.value + '"'; ## src/utils/codegen.sugar.py:883
    elif e.node_type == 'TypeNameExpression': ## src/utils/codegen.sugar.py:884
        return format_expr(e.typeName.type_ref); ## src/utils/codegen.sugar.py:885

    elif e.node_type == 'Neg': ## src/utils/codegen.sugar.py:887
        if e.type.node_type == 'Type_Bits' and not e.type.isSigned: ## src/utils/codegen.sugar.py:888
            return '(' + format_type_mask(e.type) + '(' + str(2**e.type.size) + '-' + format_expr(e.expr) + '))' ## src/utils/codegen.sugar.py:889
        else: ## src/utils/codegen.sugar.py:890
            return '(-' + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:891
    elif e.node_type == 'Cmpl': ## src/utils/codegen.sugar.py:892
        return '(' + format_type_mask(e.type) + '(~' + format_expr(e.expr) + '))' ## src/utils/codegen.sugar.py:893
    elif e.node_type == 'LNot': ## src/utils/codegen.sugar.py:894
        return '(!' + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:895

    elif e.node_type in simple_binary_ops and e.node_type == 'Equ' and e.left.type.size > 32: ## src/utils/codegen.sugar.py:897
        return "0 == memcmp({}, {}, ({} + 7) / 8)".format(format_expr(e.left), format_expr(e.right), e.left.type.size) ## src/utils/codegen.sugar.py:898

    elif e.node_type in simple_binary_ops: ## src/utils/codegen.sugar.py:900
        return '(({}){}({}))'.format(format_expr(e.left), simple_binary_ops[e.node_type], format_expr(e.right)) ## src/utils/codegen.sugar.py:901

    #Subtraction on unsigned values is performed by adding the negation of the second operand ## src/utils/codegen.sugar.py:903
    elif e.node_type == 'Sub' and e.type.node_type == 'Type_Bits' and not e.type.isSigned: ## src/utils/codegen.sugar.py:904
        return '(' + format_type_mask(e.type) + '(' + format_expr(e.left) + '+(' + str(2**e.type.size) + '-' + format_expr(e.right) + ')))' ## src/utils/codegen.sugar.py:905
    #Right shift on signed values is performed with a shift width check ## src/utils/codegen.sugar.py:906
    elif e.node_type == 'Shr' and e.type.node_type == 'Type_Bits' and e.type.isSigned: ## src/utils/codegen.sugar.py:907
        return '(({1}>{2}) ? 0 : ({0} >> {1}))'.format(format_expr(e.left), format_expr(e.right), e.type.size) ## src/utils/codegen.sugar.py:908
    #These formatting rules MUST follow the previous special cases ## src/utils/codegen.sugar.py:909
    elif e.node_type in complex_binary_ops: ## src/utils/codegen.sugar.py:910
        temp_expr = '(' + format_expr(e.left) + complex_binary_ops[e.node_type] + format_expr(e.right) + ')' ## src/utils/codegen.sugar.py:911
        if e.type.node_type == 'Type_InfInt': ## src/utils/codegen.sugar.py:912
            return temp_expr ## src/utils/codegen.sugar.py:913
        elif e.type.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:914
            if not e.type.isSigned: ## src/utils/codegen.sugar.py:915
                return '(' + format_type_mask(e.type) + temp_expr + ')' ## src/utils/codegen.sugar.py:916
            else: ## src/utils/codegen.sugar.py:917
                if e.type.size in {8,16,32}: ## src/utils/codegen.sugar.py:918
                    return '((' + format_type(e.type) + ') ' + temp_expr + ')' ## src/utils/codegen.sugar.py:919
                else: ## src/utils/codegen.sugar.py:920
                    addError('formatting an expression', 'Expression of type %s is not supported on int<%s>. (Only int<8>, int<16> and int<32> are supported.)' % (e.node_type, e.type.size)) ## src/utils/codegen.sugar.py:921
                    return '' ## src/utils/codegen.sugar.py:922

    elif e.node_type == 'Mux': ## src/utils/codegen.sugar.py:924
        return '(' + format_expr(e.e0) + '?' + format_expr(e.e1) + ':' + format_expr(e.e2) + ')' ## src/utils/codegen.sugar.py:925

    elif e.node_type == 'Slice': ## src/utils/codegen.sugar.py:927
        return '(' + format_type_mask(e.type) + '(' + format_expr(e.e0) + '>>' + format_expr(e.e2) + '))' ## src/utils/codegen.sugar.py:928

    elif e.node_type == 'Concat': ## src/utils/codegen.sugar.py:930
        return '((' + format_expr(e.left) + '<<' + str(e.right.type.size) + ') | ' + format_expr(e.right) + ')' ## src/utils/codegen.sugar.py:931

    elif e.node_type == 'Cast': ## src/utils/codegen.sugar.py:933
        if e.expr.type.node_type == 'Type_Bits' and not e.expr.type.isSigned and e.expr.type.size == 1 \
                and e.destType.node_type == 'Type_Boolean':        #Cast from bit<1> to bool ## src/utils/codegen.sugar.py:935
            return '(' + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:936
        elif e.expr.type.node_type == 'Type_Boolean' and e.destType.node_type == 'Type_Bits' and not e.destType.isSigned \
                and e.destType.size == 1:                          #Cast from bool to bit<1> ## src/utils/codegen.sugar.py:938
            return '(' + format_expr(e.expr) + '? 1 : 0)' ## src/utils/codegen.sugar.py:939
        elif e.expr.type.node_type == 'Type_Bits' and e.destType.node_type == 'Type_Bits': ## src/utils/codegen.sugar.py:940
            if e.expr.type.isSigned == e.destType.isSigned: ## src/utils/codegen.sugar.py:941
                if not e.expr.type.isSigned:                       #Cast from bit<w> to bit<v> ## src/utils/codegen.sugar.py:942
                    if e.expr.type.size > e.destType.size: ## src/utils/codegen.sugar.py:943
                        return '(' + format_type_mask(e.destType) + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:944
                    else: ## src/utils/codegen.sugar.py:945
                        return format_expr(e.expr) ## src/utils/codegen.sugar.py:946
                else:                                              #Cast from int<w> to int<v> ## src/utils/codegen.sugar.py:947
                    return '((' + format_type(e.destType) + ') ' + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:948
            elif e.expr.type.isSigned and not e.destType.isSigned: #Cast from int<w> to bit<w> ## src/utils/codegen.sugar.py:949
                return '(' + format_type_mask(e.destType) + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:950
            elif not e.expr.type.isSigned and e.destType.isSigned: #Cast from bit<w> to int<w> ## src/utils/codegen.sugar.py:951
                if e.destType.size in {8,16,32}: ## src/utils/codegen.sugar.py:952
                    return '((' + format_type(e.destType) + ')' + format_expr(e.expr) + ')' ## src/utils/codegen.sugar.py:953
                else: ## src/utils/codegen.sugar.py:954
                    addError('formatting an expression', 'Cast from bit<%s> to int<%s> is not supported! (Only int<8>, int<16> and int<32> are supported.)' % e.destType.size) ## src/utils/codegen.sugar.py:955
                    return '' ## src/utils/codegen.sugar.py:956
        #Cast from int to bit<w> and int<w> are performed by P4C ## src/utils/codegen.sugar.py:957
        addError('formatting an expression', 'Cast from %s to %s is not supported!' % (pp_type_16(e.expr.type), pp_type_16(e.destType))) ## src/utils/codegen.sugar.py:958
        return '' ## src/utils/codegen.sugar.py:959

    elif e.node_type == 'ListExpression': ## src/utils/codegen.sugar.py:961
        if e.id not in generated_exprs: ## src/utils/codegen.sugar.py:962
            prepend_statement(listexpression_to_buf(e)) ## src/utils/codegen.sugar.py:963
            generated_exprs.add(e.id) ## src/utils/codegen.sugar.py:964
        return '(struct uint8_buffer_s) {{ .buffer =  buffer{}, .buffer_size = buffer{}_size }}'.format(e.id, e.id) ## src/utils/codegen.sugar.py:965
        # return 'buffer{}, buffer{}_size'.format(e.id, e.id) ## src/utils/codegen.sugar.py:966
    elif e.node_type == 'SelectExpression': ## src/utils/codegen.sugar.py:967
        #Generate local variables for select values ## src/utils/codegen.sugar.py:968
        for k in e.select.components: ## src/utils/codegen.sugar.py:969
            varname = gen_var_name(k) ## src/utils/codegen.sugar.py:970
            if k.type.node_type == 'Type_Bits' and k.type.size <= 32: ## src/utils/codegen.sugar.py:971
                prepend_statement(' {} {} = {}; // (prepended) src/utils/codegen.sugar.py:971\n'.format(format_type(k.type), varname, format_expr(k))) ## src/utils/codegen.sugar.py:972
            elif k.type.node_type == 'Type_Bits' and k.type.size % 8 == 0: ## src/utils/codegen.sugar.py:973
                prepend_statement(' uint8_t {}[{}]; // (prepended) src/utils/codegen.sugar.py:973\n'.format(varname, k.type.size/8)) ## src/utils/codegen.sugar.py:974
                prepend_statement(" EXTRACT_BYTEBUF_PACKET(pd, {}, {});' // (prepended) src/utils/codegen.sugar.py:974\n".format(format_expr(k, False), varname)) ## src/utils/codegen.sugar.py:975
            else: ## src/utils/codegen.sugar.py:976
                addError('formatting select expression', 'Select on type %s is not supported!' % pp_type_16(k.type)) ## src/utils/codegen.sugar.py:977

        cases = [] ## src/utils/codegen.sugar.py:979
        for case in e.selectCases: ## src/utils/codegen.sugar.py:980
            cases_tmp = case.keyset.components if case.keyset.node_type == 'ListExpression' else [case.keyset] ## src/utils/codegen.sugar.py:981
            conds = [] ## src/utils/codegen.sugar.py:982
            for k, c in zip(e.select.components, cases_tmp): ## src/utils/codegen.sugar.py:983
                select_type = k.type.node_type ## src/utils/codegen.sugar.py:984
                size = k.type.size #if k.type.node_type == 'Type_Bits' else 0 ## src/utils/codegen.sugar.py:985
                case_type = c.node_type ## src/utils/codegen.sugar.py:986

                if case_type == 'DefaultExpression': ## src/utils/codegen.sugar.py:988
                    conds.append('true /* default */') ## src/utils/codegen.sugar.py:989
                elif case_type == 'Constant' and select_type == 'Type_Bits' and 32 < size and size % 8 == 0: ## src/utils/codegen.sugar.py:990
                    byte_array = int_to_big_endian_byte_array_with_length(c.value, size/8) ## src/utils/codegen.sugar.py:991
                    prepend_statement(' uint8_t {}[{}] = {}; // (prepended) src/utils/codegen.sugar.py:991\n'.format(gen_var_name(c), size/8, byte_array)) ## src/utils/codegen.sugar.py:992
                    conds.append('memcmp({}, {}, {}) == 0'.format(gen_var_name(k), gen_var_name(c), size/8)) ## src/utils/codegen.sugar.py:993
                elif size <= 32: ## src/utils/codegen.sugar.py:994
                    if case_type == 'Range': ## src/utils/codegen.sugar.py:995
                        conds.append('{0} <= {1} && {1} <= {2}'.format(format_expr(c.left), gen_var_name(k), format_expr(c.right))) ## src/utils/codegen.sugar.py:996
                    elif case_type == 'Mask': ## src/utils/codegen.sugar.py:997
                        conds.append('({0} & {1}) == ({2} & {1})'.format(format_expr(c.left), format_expr(c.right), gen_var_name(k))) ## src/utils/codegen.sugar.py:998
                    else: ## src/utils/codegen.sugar.py:999
                        if case_type not in {'Constant'}: #Trusted expressions ## src/utils/codegen.sugar.py:1000
                            addWarning('formatting a select case', 'Select statement cases of type %s on %s might not work properly.' ## src/utils/codegen.sugar.py:1001
                                       % (case_type, pp_type_16(k.type))) ## src/utils/codegen.sugar.py:1002
                        conds.append('{} == {}'.format(gen_var_name(k), format_expr(c))) ## src/utils/codegen.sugar.py:1003
                else: ## src/utils/codegen.sugar.py:1004
                    addError('formatting a select case', 'Select statement cases of type %s on %s is not supported!' ## src/utils/codegen.sugar.py:1005
                             % (case_type, pp_type_16(k.type))) ## src/utils/codegen.sugar.py:1006
            cases.append('if({0}){{parser_state_{1}(pd, buf, tables, pstate);}}'.format(' && '.join(conds), format_expr(case.state))) ## src/utils/codegen.sugar.py:1007
        return '\nelse\n'.join(cases) ## src/utils/codegen.sugar.py:1008

    elif e.node_type == 'PathExpression': ## src/utils/codegen.sugar.py:1010
        if is_control_local_var(e.ref.name): ## src/utils/codegen.sugar.py:1011
            return "local_vars->" + e.ref.name ## src/utils/codegen.sugar.py:1012
        if expand_parameters and not e.path.absolute: ## src/utils/codegen.sugar.py:1013
            return "parameters." + e.ref.name ## src/utils/codegen.sugar.py:1014
        return e.ref.name ## src/utils/codegen.sugar.py:1015

    elif e.node_type == 'Member': ## src/utils/codegen.sugar.py:1017
        if hasattr(e, 'field_ref'): ## src/utils/codegen.sugar.py:1018
            if format_as_value == False: ## src/utils/codegen.sugar.py:1019
                return fldid(e.expr.header_ref, e.field_ref) # originally it was fldid2 ## src/utils/codegen.sugar.py:1020

            if e.type.size > 32: ## src/utils/codegen.sugar.py:1022
                var_name = generate_var_name("hdr_{}_{}".format(e.expr.header_ref.id, e.field_ref.id)) ## src/utils/codegen.sugar.py:1023
                byte_size = (e.type.size + 7) / 8 ## src/utils/codegen.sugar.py:1024

                prepend_statement(' uint8_t* {}[{}]; // (prepended) src/utils/codegen.sugar.py:1025\n'.format(var_name, byte_size)) ## src/utils/codegen.sugar.py:1026
                prepend_statement(' EXTRACT_BYTEBUF_PACKET(pd, {}, {}, {}); // (prepended) src/utils/codegen.sugar.py:1026\n'.format(e.expr.header_ref.id, e.field_ref.id, var_name)) ## src/utils/codegen.sugar.py:1027

                return var_name ## src/utils/codegen.sugar.py:1029

            hdrinst = 'header_instance_all_metadatas' if e.expr.header_ref._type.type_ref.is_metadata else e.expr.header_ref.id ## src/utils/codegen.sugar.py:1031
            return '(GET_INT32_AUTO_PACKET(pd, {}, {}))'.format(hdrinst, e.field_ref.id) ## src/utils/codegen.sugar.py:1032
        elif hasattr(e, 'header_ref'): ## src/utils/codegen.sugar.py:1033
            # TODO do both individual meta fields and metadata instance fields ## src/utils/codegen.sugar.py:1034
            if e.header_ref.name == 'metadata': ## src/utils/codegen.sugar.py:1035
                generated_code += add_code(' pd->fields.field_instance_{}_{}'.format(e.expr.member, e.member), 1035)
            return e.header_ref.id ## src/utils/codegen.sugar.py:1037
        elif e.expr.node_type == 'PathExpression': ## src/utils/codegen.sugar.py:1038
            var = e.expr.ref.name ## src/utils/codegen.sugar.py:1039

            if e.expr.type.node_type == 'Type_Header': ## src/utils/codegen.sugar.py:1041
                h = e.expr.type ## src/utils/codegen.sugar.py:1042
                return '(GET_INT32_AUTO_PACKET(pd, header_instance_{}, field_{}_{}))'.format(var, h.name, e.member) ## src/utils/codegen.sugar.py:1043
            else: ## src/utils/codegen.sugar.py:1044
                generated_code += add_code(' {}.{}'.format(format_expr(e.expr), e.member), 1044)
        else: ## src/utils/codegen.sugar.py:1046
            if e.type.node_type in {'Type_Enum', 'Type_Error'}: ## src/utils/codegen.sugar.py:1047
                generated_code += add_code(' {}'.format(e.type.members.get(e.member).c_name), 1047)
            elif e.expr('expr', lambda e2: e2.type.name == 'parsed_packet'): ## src/utils/codegen.sugar.py:1049
                generated_code += add_code(' pd->fields.field_instance_{}_{}'.format(e.expr.member, e.member), 1049)
            else: ## src/utils/codegen.sugar.py:1051
                generated_code += add_code(' {}.{}'.format(format_expr(e.expr), e.member), 1051)
    # TODO some of these are formatted as statements, we shall fix this ## src/utils/codegen.sugar.py:1053
    elif e.node_type == 'MethodCallExpression': ## src/utils/codegen.sugar.py:1054
        special_methods = { ## src/utils/codegen.sugar.py:1055
            ('Member', 'setValid'):     gen_method_setValid, ## src/utils/codegen.sugar.py:1056
            ('Member', 'isValid'):      gen_method_isValid, ## src/utils/codegen.sugar.py:1057
            ('Member', 'setInvalid'):   gen_method_setInvalid, ## src/utils/codegen.sugar.py:1058
            ('Member', 'apply'):        gen_method_apply, ## src/utils/codegen.sugar.py:1059
        } ## src/utils/codegen.sugar.py:1060

        method = special_methods.get((e.method.node_type, e.method.member)) if e.method.get_attr('member') is not None else None ## src/utils/codegen.sugar.py:1062

        if method: ## src/utils/codegen.sugar.py:1064
            generated_code += add_code(' {}'.format(method(e)), 1064)
        elif e.arguments.is_vec() and e.arguments.vec != []: ## src/utils/codegen.sugar.py:1066
            # TODO is this right? shouldn't e.method always have a .ref? ## src/utils/codegen.sugar.py:1067
            if e.method.get_attr('ref') is None: ## src/utils/codegen.sugar.py:1068
                mref = e.method.expr.ref ## src/utils/codegen.sugar.py:1069
                method_params = mref.type.type_ref.typeParameters ## src/utils/codegen.sugar.py:1070
            else: ## src/utils/codegen.sugar.py:1071
                mref = e.method.ref ## src/utils/codegen.sugar.py:1072
                method_params = mref.type.parameters ## src/utils/codegen.sugar.py:1073

            if mref.name == 'digest': ## src/utils/codegen.sugar.py:1075
                return gen_format_call_digest(e) ## src/utils/codegen.sugar.py:1076
            else: ## src/utils/codegen.sugar.py:1077
                return gen_format_call_extern(e, mref, method_params) ## src/utils/codegen.sugar.py:1078
        else: ## src/utils/codegen.sugar.py:1079
            if e.method('expr').type.node_type == 'Type_Extern': ## src/utils/codegen.sugar.py:1080
                if e.method.member in {'lookahead', 'advance', 'length'}: ## src/utils/codegen.sugar.py:1081
                    raise NotImplementedError('{}.{} is not supported yet!'.format(e.method.expr.type.name, e.method.member)) ## src/utils/codegen.sugar.py:1082

                funname = "{}_t_{}".format(e.method.expr.type.name, e.method.member) ## src/utils/codegen.sugar.py:1084
                extern_inst = format_expr(e.method.expr) ## src/utils/codegen.sugar.py:1085
                extern_type = format_type(e.method.expr.type.methods.get(e.method.member, 'Method').type.returnType) ## src/utils/codegen.sugar.py:1086
                prepend_statement("extern {} {}({}_t);\n".format(extern_type, funname, e.method.expr.type.name)) ## src/utils/codegen.sugar.py:1087
                generated_code += add_code(' {}({})'.format(funname, extern_inst), 1087)
            else: ## src/utils/codegen.sugar.py:1089
                funname = format_expr(e.method) ## src/utils/codegen.sugar.py:1090
                prepend_statement("extern void {}(SHORT_STDPARAMS);\n".format(funname)) ## src/utils/codegen.sugar.py:1091
                generated_code += add_code(' {}(SHORT_STDPARAMS_IN)'.format(funname), 1091)
    elif e.node_type == 'Argument': ## src/utils/codegen.sugar.py:1093
        return format_expr(e.expression) ## src/utils/codegen.sugar.py:1094
    elif e.node_type == 'StructInitializerExpression': ## src/utils/codegen.sugar.py:1095
        generated_code += add_code(' ({}) {{'.format(gen_format_type(e.type)), 1095)
        for component in e.components: ## src/utils/codegen.sugar.py:1097
            tref = component.expression.expr("ref.type.type_ref") ## src/utils/codegen.sugar.py:1098
            if tref and tref.is_metadata: ## src/utils/codegen.sugar.py:1099
                generated_code += add_code(' .{} = (GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_{}_{})),'.format(component.name, tref.name, component.expression.member), 1099)
            else: ## src/utils/codegen.sugar.py:1101
                if component.expression.type.size <= 32: ## src/utils/codegen.sugar.py:1102
                    generated_code += add_code(' .{} = {},'.format(component.name, gen_format_expr(component.expression)), 1102)
                else: ## src/utils/codegen.sugar.py:1104
                    generated_code += add_code(' /* {}/{}b will be initialised afterwards */'.format(component.name, component.expression.type.size), 1104)
        generated_code += add_code(" }", 1105)
    elif e.node_type == 'StructExpression': ## src/utils/codegen.sugar.py:1107
        varname = gen_var_name(e) ## src/utils/codegen.sugar.py:1108
        prepend_statement(' {} {}; // (prepended) src/utils/codegen.sugar.py:1108\n'.format(format_type(e.type), varname)) ## src/utils/codegen.sugar.py:1109
        for component in e.components: ## src/utils/codegen.sugar.py:1110
            tref = component.expression.expr("ref.type.type_ref") ## src/utils/codegen.sugar.py:1111
            if tref and tref.is_metadata: ## src/utils/codegen.sugar.py:1112
                prepend_statement(' {}.{} = (GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_{}_{})); // (prepended) src/utils/codegen.sugar.py:1112\n'.format(varname, component.name, tref.name, component.expression.member)) ## src/utils/codegen.sugar.py:1113
            else: ## src/utils/codegen.sugar.py:1114
                if component.expression.type.size <= 32: ## src/utils/codegen.sugar.py:1115
                    prepend_statement(' {}.{} = {}; // (prepended) src/utils/codegen.sugar.py:1115\n'.format(varname, component.name, gen_format_expr(component.expression))) ## src/utils/codegen.sugar.py:1116
                else: ## src/utils/codegen.sugar.py:1117
                    indirection = "&" if is_primitive(component.expression.type) else "" ## src/utils/codegen.sugar.py:1118
                    refbase = "local_vars->" if is_control_local_var(component.name) else 'parameters.' ## src/utils/codegen.sugar.py:1119
                    bitsize = (component.expression.type.size+7)/8 ## src/utils/codegen.sugar.py:1120
                    hdrinst = component.expression.expr.header_ref.name ## src/utils/codegen.sugar.py:1121
                    fldinst = component.expression.member ## src/utils/codegen.sugar.py:1122
                    prepend_statement(' EXTRACT_BYTEBUF_PACKET(pd, header_instance_{}, field_instance_{}_{}, &({}.{})); // (prepended) src/utils/codegen.sugar.py:1122\n'.format(hdrinst, hdrinst, fldinst, varname, component.name)) ## src/utils/codegen.sugar.py:1123
        generated_code += add_code(' {}'.format(varname), 1123)
    else: ## src/utils/codegen.sugar.py:1125
        addError("formatting an expression", "Expression of type %s is not supported yet!" % e.node_type) ## src/utils/codegen.sugar.py:1126


    return generated_code

# TODO remove duplication (actions, dataplane) ## src/utils/codegen.sugar.py:1129
class types: ## src/utils/codegen.sugar.py:1130
    def __init__(self, new_type_env): ## src/utils/codegen.sugar.py:1131
        global type_env ## src/utils/codegen.sugar.py:1132
        self.env_vars = set() ## src/utils/codegen.sugar.py:1133
        for v in new_type_env: ## src/utils/codegen.sugar.py:1134
            if v in type_env: ## src/utils/codegen.sugar.py:1135
                addWarning('adding a type environment', 'variable {} is already bound to type {}'.format(v, type_env[v])) ## src/utils/codegen.sugar.py:1136
            else: ## src/utils/codegen.sugar.py:1137
                self.env_vars.add(v) ## src/utils/codegen.sugar.py:1138
                type_env[v] = new_type_env[v] ## src/utils/codegen.sugar.py:1139

    def __enter__(self): ## src/utils/codegen.sugar.py:1141
        global type_env ## src/utils/codegen.sugar.py:1142
        return type_env ## src/utils/codegen.sugar.py:1143

    def __exit__(self, type, value, traceback): ## src/utils/codegen.sugar.py:1145
        global type_env ## src/utils/codegen.sugar.py:1146
        for v in self.env_vars: ## src/utils/codegen.sugar.py:1147
            del type_env[v] ## src/utils/codegen.sugar.py:1148

def gen_format_call_extern(e, mref, method_params): ## src/utils/codegen.sugar.py:1150
    generated_code = ""
    # TODO temporary fix, this will be computed later on ## src/utils/codegen.sugar.py:1151
    with types({ ## src/utils/codegen.sugar.py:1152
        "T": "struct uint8_buffer_s", ## src/utils/codegen.sugar.py:1153
        "O": "unsigned", ## src/utils/codegen.sugar.py:1154
        "HashAlgorithm": "int", ## src/utils/codegen.sugar.py:1155
    }): ## src/utils/codegen.sugar.py:1156







        fmt_params = format_method_parameters(e.arguments, method_params) ## src/utils/codegen.sugar.py:1164
        all_params = ", ".join([p for p in [fmt_params, "SHORT_STDPARAMS_IN"] if p != '']) ## src/utils/codegen.sugar.py:1165

        # test!!!!! ## src/utils/codegen.sugar.py:1167



        return_type = format_type(mref.type.returnType) ## src/utils/codegen.sugar.py:1171
        param_types = ", ".join([format_type(tpar) for (par, tpar) in method_parameters_by_type(e.arguments, method_params)] + ["SHORT_STDPARAMS"]) ## src/utils/codegen.sugar.py:1172




        # test!!!!! ## src/utils/codegen.sugar.py:1177
        prepend_statement(' extern {} {}({}); // (prepended) src/utils/codegen.sugar.py:1177\n'.format(format_type(e.type), mref.name, param_types)) ## src/utils/codegen.sugar.py:1178
        generated_code += add_code(' {}({})'.format(mref.name, all_params), 1178)

    return generated_code

def gen_format_call_digest(e): ## src/utils/codegen.sugar.py:1181
    generated_code = ""
    prepend_statement(" #ifdef T4P4S_NO_CONTROL_PLANE") ## src/utils/codegen.sugar.py:1182
    prepend_statement(" #error \"Generating digest when T4P4S_NO_CONTROL_PLANE is defined\"") ## src/utils/codegen.sugar.py:1183
    prepend_statement(" #endif") ## src/utils/codegen.sugar.py:1184

    prepend_statement(' debug("    " T4LIT(<,outgoing) " " T4LIT(Sending digest,outgoing) " to port " T4LIT(%d,port) "\\n", {}); // (prepended) src/utils/codegen.sugar.py:1185\n'.format(e.arguments[0].expression.value)) ## src/utils/codegen.sugar.py:1186
    for c in e.arguments[1].expression.components: ## src/utils/codegen.sugar.py:1187
        cexpr = c.expression ## src/utils/codegen.sugar.py:1188
        hdr = cexpr.expr.path.name if cexpr.expr('header_ref', lambda h: h._type._type_ref.is_metadata) else cexpr.expr.header_ref._type_ref.name ## src/utils/codegen.sugar.py:1189
        prepend_statement(' dbg_bytes(field_desc(pd, field_instance_{}_{}).byte_addr, ({}+7)/8, "        : "T4LIT({},field)"/"T4LIT({})" = "); // (prepended) src/utils/codegen.sugar.py:1189\n'.format(hdr, cexpr.member, cexpr.type.size, cexpr.member, cexpr.type.size)) ## src/utils/codegen.sugar.py:1190
    append_statement(" sleep_millis(300);") ## src/utils/codegen.sugar.py:1191

    id = e.id ## src/utils/codegen.sugar.py:1193
    name = e.typeArguments['Type_Name'][0].path.name ## src/utils/codegen.sugar.py:1194
    receiver = e.arguments[0].expression.value ## src/utils/codegen.sugar.py:1195
    
    prepend_statement(' ctrl_plane_digest digest{} = create_digest(bg, "{}"); // (prepended) src/utils/codegen.sugar.py:1196\n'.format(id, name)) ## src/utils/codegen.sugar.py:1197
    for fld in e.arguments[1].expression.components: ## src/utils/codegen.sugar.py:1198
        bitsize = fld.expression.type.size ## src/utils/codegen.sugar.py:1199
        fe = fld.expression ## src/utils/codegen.sugar.py:1200
        hdr = fe.expr.path.name if fe.expr('header_ref', lambda h: h._type._type_ref.is_metadata) else fe.expr.header_ref._type_ref.name ## src/utils/codegen.sugar.py:1201
        prepend_statement(' add_digest_field(digest{}, field_desc(pd, field_instance_{}_{}).byte_addr, {}); // (prepended) src/utils/codegen.sugar.py:1201\n'.format(id, hdr, fe.member, bitsize)) ## src/utils/codegen.sugar.py:1202

    generated_code += add_code(' send_digest(bg, digest{}, {})'.format(id, receiver), 1203)

    return generated_code

################################################################################ ## src/utils/codegen.sugar.py:1206

def format_declaration(d, varname_override = None): ## src/utils/codegen.sugar.py:1208
    global file_sugar_style ## src/utils/codegen.sugar.py:1209
    with SugarStyle("no_comment"): ## src/utils/codegen.sugar.py:1210
        return gen_format_declaration(d, varname_override) ## src/utils/codegen.sugar.py:1211

# TODO use the variable_name argument in all cases where a variable declaration is created ## src/utils/codegen.sugar.py:1213
def format_type(t, variable_name = None, resolve_names = True, addon = ""): ## src/utils/codegen.sugar.py:1214
    global file_sugar_style ## src/utils/codegen.sugar.py:1215
    with SugarStyle("inline_comment"): ## src/utils/codegen.sugar.py:1216
        result = gen_format_type(t, resolve_names, variable_name is not None, addon).strip() ## src/utils/codegen.sugar.py:1217

        if variable_name is None: ## src/utils/codegen.sugar.py:1219
            return result ## src/utils/codegen.sugar.py:1220

        split = result.split(" ") ## src/utils/codegen.sugar.py:1222
        essential_portion = 2 if split[0] in ['enum', 'struct'] else 1 ## src/utils/codegen.sugar.py:1223
        return "{} {}{}".format(" ".join(split[0:essential_portion]), variable_name, " ".join(split[essential_portion:])) ## src/utils/codegen.sugar.py:1224

def format_method_parameters(ps, mt): ## src/utils/codegen.sugar.py:1226
    global file_sugar_style ## src/utils/codegen.sugar.py:1227
    with SugarStyle("inline_comment"): ## src/utils/codegen.sugar.py:1228
        return gen_format_method_parameters(ps, mt) ## src/utils/codegen.sugar.py:1229

def format_expr(e, format_as_value=True, expand_parameters=False): ## src/utils/codegen.sugar.py:1231
    global file_sugar_style ## src/utils/codegen.sugar.py:1232
    with SugarStyle("inline_comment"): ## src/utils/codegen.sugar.py:1233
        return gen_format_expr(e, format_as_value, expand_parameters) ## src/utils/codegen.sugar.py:1234

def format_statement(stmt, ctl=None): ## src/utils/codegen.sugar.py:1236
    global enclosing_control ## src/utils/codegen.sugar.py:1237
    if ctl is not None: ## src/utils/codegen.sugar.py:1238
        enclosing_control = ctl ## src/utils/codegen.sugar.py:1239

    global pre_statement_buffer ## src/utils/codegen.sugar.py:1241
    global post_statement_buffer ## src/utils/codegen.sugar.py:1242
    pre_statement_buffer = "" ## src/utils/codegen.sugar.py:1243
    post_statement_buffer = "" ## src/utils/codegen.sugar.py:1244

    ret = gen_format_statement(stmt) ## src/utils/codegen.sugar.py:1246

    pre_statement_buffer_ret = pre_statement_buffer ## src/utils/codegen.sugar.py:1248
    pre_statement_buffer = "" ## src/utils/codegen.sugar.py:1249
    post_statement_buffer_ret = post_statement_buffer ## src/utils/codegen.sugar.py:1250
    post_statement_buffer = "" ## src/utils/codegen.sugar.py:1251
    return pre_statement_buffer_ret + ret + post_statement_buffer_ret ## src/utils/codegen.sugar.py:1252


def format_type_mask(t): ## src/utils/codegen.sugar.py:1255
    global file_sugar_style ## src/utils/codegen.sugar.py:1256
    with SugarStyle("inline_comment"): ## src/utils/codegen.sugar.py:1257
        return gen_format_type_mask(t) ## src/utils/codegen.sugar.py:1258

def gen_var_name(item, prefix = None): ## src/utils/codegen.sugar.py:1260
    generated_code = ""
    if not prefix: ## src/utils/codegen.sugar.py:1261
        prefix = "value_" + str(item.node_type) ## src/utils/codegen.sugar.py:1262
    generated_code += add_code(' {}_{}'.format(prefix, item.id), 1262)
    return generated_code

